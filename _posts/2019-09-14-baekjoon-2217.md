---
layout: post
title: "백준 2217번 : 로프"
tags: [알고리즘, 백준, Greedy]
comments: true
---

> BOJ  

### 문제설명  
N(1≤N≤100,000)개의 로프가 있다. 이 로프를 이용하여 이런 저런 물체를 들어올릴 수 있다. 각각의 로프는 그 굵기나 길이가 다르기 때문에 들 수 있는 물체의 중량이 서로 다를 수도 있다.  

하지만 여러 개의 로프를 병렬로 연결하면 각각의 로프에 걸리는 중량을 나눌 수 있다. k개의 로프를 사용하여 중량이 w인 물체를 들어올릴 때, 각각의 로프에는 모두 고르게 w/k 만큼의 중량이 걸리게 된다.  

각 로프들에 대한 정보가 주어졌을 때, 이 로프들을 이용하여 들어올릴 수 있는 물체의 최대 중량을 구해내는 프로그램을 작성하시오. 모든 로프를 사용해야 할 필요는 없으며, 임의로 몇 개의 로프를 골라서 사용해도 된다. 단, 각각의 로프는 한 개씩만 존재한다.  

입력  
첫째 줄에 정수 N이 주어진다. 다음 N개의 줄에는 각 로프가 버틸 수 있는 최대 중량이 주어진다. 이 값은 10,000을 넘지 않는 정수이다.  

출력  
첫째 줄에 답을 출력한다.  

### 접근  
이 문제의 핵심은 아무리 많은 로프를 병렬로 연결시켜서 중량을 나눈다고 해도 결국에는 최대 중량이 가장 적은 로프가 들 수 있는 중량만큼이 최댓값이라는 점이다. 예를 들어 로프가 2개이고 각각 버틸 수 있는 중량이 10, 15라고 하자. 그렇다면 경우의 수는 다음의 세 가지다.  

첫 번째 로프만 쓸 경우 : 최대 중량 10   
두 번째 로프만 쓸 경우 : 최대 중량 15  
두 로프를 병렬로 연결할 경우 : 최대 중량 각각 20, 30  

두 로프를 병렬로 연결하면 두 번째 로프 입장에서는 30을 들 수 있을 것 같지만 사실은 20밖에 들지 못하는 것이다. (첫 번째 로프도 사용해야 하는데 그 로프의 최대 중량이 20이므로)  

여러 로프를 중량 기준 오름차순정렬하고 i = 0부터 N-1까지 iterate 한다고 햇을 때 최대 중량의 값은 i번째 로프의 중량 * (N-i)인 것이다. 즉, 처음(가장 중량이 낮은)로프를 선택할 경우 그 로프의 입장에서는 최대한 많은 로프를 병렬로 연결해야 무게를 더 들 수 있다. 그리고 그 로프가 선택되었을때 오름차순으로 정렬되어 있기 때문에 자신의 무게가 upper bound가 된다. 또한 혼자 무게를 많이 들 수 있는 로프일 수록 병렬로 연결할 필요가 없다. 따라서 각 i번째 로프의 중량에 N-i개의 로프 수를 곱해주는 것이다.  

논리는 이해했는데 왜 이 문제가 greedy algorithm 카테고리인지는 아직 감이 안온다(?)  

### 코드  
~~~c++
#include <cstdio>
#include <algorithm>

using namespace std;

int max(int a, int b) { return a > b ? a : b; }

int main() {
    int N, i, ans = 0;
    
    scanf("%d", &N);
    int arr[N];

    for (i = 0; i < N; i++) scanf("%d", &arr[i]);
    sort(arr, arr+N);
    for (i = 0; i < N; i++) ans = max(ans, arr[i]*(N-i));
    printf("%d\n", ans);

    return 0;
}
~~~