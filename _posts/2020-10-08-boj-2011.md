---
layout: post
title: "백준 2011번 : 암호코드"
tags: [알고리즘, 백준, DP]
comments: true
---

> BOJ  

[암호코드 문제링크](https://www.acmicpc.net/problem/2011)  

### 접근  
간단한 문제라고 생각하고 접근했는데 예외처리 때문에 애를 먹었다. 초기접근은 아래와 같다.  

문자열의 뒤에서부터 순회하며 한 자리 수 단위로 잘랐을 때의 경우의 수를 기록한다. 그리고 i번째 숫자와 i+1번째 숫자를 조합하여 두 자리 수 단위로 잘랐을 때 알파벳으로 해석이 가능하다면 s[i], s[i+1]을 하나의 알파벳으로 간주하고 s[i+2]부터 해석될 수 있는 경우의 수(이미 기록해놓았다)를 더해준다.  

25114를 예로 들어보자. s[4] 위치의 숫자 4는 0이 아니므로 D라는 알파벳으로 해석될 수 있다. 1가지 경우밖에 없으므로 dp[4]에 1을 기록한다. 이제 s[3]으로 동일하게 알파벳으로 해석될 수 있는지 검사한다. 가능하다면 dp[3+1]의 경우의 수를 그대로 가져온다. 즉, 14를 AD로 해석하는 것이다.  

그리고 s[3]과 s[4]를 하나의 알파벳으로 해석할 수 있는지 검사한다. 10 이상 26 이하이므로 14를 N으로 해석할 수 있다. 그러므로 s[3]s[4]를 하나의 알파벳으로 묶고 맨 뒤부터 s[5]까지의 해석될 수 있는 경우의 수를 더해준다. 경우의 수는 dp 배열에 기록하면서 순회하므로 이미 계산한 값을 가져다 쓴다.  

여기까지는 어렵지 않게 떠올릴 수 있었는데 0이 문제였다. 단순히 0이 문자열에 포함되면 올바른 암호가 아닐거라 생각했지만 두 글자로 묶었을 때 알파벳으로 해석될 수 있다면 유효한 암호이다. 예외처리는 아래 두가지에 대해서 해주었다.  
1. 첫 문자가 0일 경우  
2. 30, 40과 같이 두 숫자를 하나로 합쳐도 알파벳으로 해석할 수 있는 범위를 넘어간 경우  

### 코드  
~~~c++
#include <iostream>
#include <string>
using namespace std;

#define MOD 1000000

int main() {
    string s;
    cin >> s;

    bool flag = true;
    int len = s.length();
    long long dp[len + 1];

    dp[len] = 1;
    if (s[0] == '0') {
        // 첫 문자가 0이면 올바르지 않은 암호
        flag = false;
    } else {
        if (s[len-1] == '0') {
            dp[len-1] = 0;
        } else {
            dp[len-1] = 1;
        }

        for (int i = len - 2; i >= 0; i--) {
            if (s[i] == '0') {
                // 현재 위치의 숫자가 0이라면 해석될 수 있는 여지는 없으므로 0
                // 하지만 다음 위치의 수(s[i-1])와 조합해서 10, 20 등의 암호를 만들어 낼 수 있으므로 break 하지 않음
                dp[i] = 0;
            } else {
                // 현재 위치의 숫자가 0이 아니라면 1개 단위로 잘랐을 때 이전까지의 암호를 해석할 수 있는 가짓수와 동일
                dp[i] = dp[i + 1] % MOD;

                int temp = ((s[i] - '0') * 10) + (s[i + 1] - '0');
                // 2자리를 조합했봄으로써 더 해석될 수 있는 여지가 있는지 검사
                if (temp >= 10 && temp <= 26) {
                    // 만약 10~26 사이의 수라면 s[i], s[i+1]을 하나의 알파벳으로 해석하고 s[i+2]까지 해석된 가짓수를 더함
                    dp[i] += dp[i + 2] % MOD;
                } else if (s[i+1] == '0') {
                    // 30, 40같은 수는 두자리수는 만들어지지만 알파벳으로 해석할 수 없으므로 올바르지 않은 암호
                    flag = false;
                    break;
                }
            }
        }
    }


    flag ? printf("%lld\n", dp[0] % MOD) : printf("0\n");

    return 0;
}
~~~
