---
layout: post
title: "백준 12015번 : 가장 긴 증가하는 부분 수열 2"
tags: [알고리즘, 백준, LIS]
comments: true
---

> BOJ  

### 문제설명  
수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.  

예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10, 20, 10, 30, 20, 50} 이고, 길이는 4이다.  

입력  
첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다.  

둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000,000)  

출력  
첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.  

### 접근  
[백준 11053번 : 가장 긴 증가하는 부분 수열](https://www.acmicpc.net/problem/11053) 문제의 시리즈 문제라고 할 수 있다 (풀이는 [여기](https://sihyungyou.github.io/baekjoon-11053/))  

이 문제의 차이점은 수열 A의 크기가 1000개에서 1000000개로 늘어났다는 점이다. 이 차이점 때문에 오늘 많이 배웠다. 첫번째로 데이터의 갯수에 따라 단순히 배열의 데이터 타입 뿐만 아니라 알고리즘 자체가 바뀌어야 할 수도 있다는 것. 두번째로 vector STL에서 lower_bound라는 함수를 배웠다.  

11053번 문제를 풀 때는 수열을 기록해놓은 arr, 길이를 기록해놓은 dp 배열을 따로 두어 수열의 각 값들이 처음 입력받은 수 부터 자기자신까지 몇 번 증가하는지 매번 확인하고 기록했다. 하지만 데이터의 갯수가 1000000개라면 이런 O(N^2) 시간복잡도를 가진 알고리즘은 시간초과가 난다.  

12015번 문제는 이분탐색을 사용해서 풀어야 한다. 알고리즘의 진행은 다음과 같다.  
1. 벡터를 생성하고 최솟값 하나를 넣어둔다.  
2. 입력받은 수 x와 벡터의 끝값 back을 비교해서 x가 더 크다면 push back 하고 길이 변수 cnt를 1 증가시킨다.  
3. back이 x보다 크거나 같다면 lower bound를 찾고 그 위치에 x를 넣는다.  

여기서 핵심은 LIS 벡터는 기존 수열과 전혀 상관 없이, 증가하는 부분 수열의 조건에 맞는지만 검사하고 길이를 증가시킨다는 것과 이분탐색을 내가 직접 구현하지 않고 lower_bound() 함수를 쓰면 된다는 것이다. 예를 들어 수열 A = [10, 20, 40, 25, 20, 50, 30, 70, 85]라고 하자. 그러면 LIS vector는 아래와 같이 진행될 것이다.  

~~~
LIS vector             수열
[INT_MIN]              x = 10 => [10]               cnt : 0 -> 1
[10]                   x = 20 => [10, 20]           cnt : 1 -> 2
[10, 20]               x = 40 => [10, 20, 40]       cnt : 2 -> 3
[10, 20, 40]           x = 25 => [10, 20, 25]       lower bound : 40 -> x로 교체
[10, 20, 25]           x = 20 => [10, 20, 25]       lower bound : 20 -> x로 교체
[10, 20, 25]           x = 50 => [10, 20, 25, 50]   cnt : 3 -> 4
[10, 20, 25, 50]       x = 30 => [10, 20, 25, 30]   lower bound : 50 -> x로 교체
...
~~~

lower bound는 삽입되는 x보다 크거나 같은 첫번째 원소의 위치를 반환하므로 그 앞은 x보다 작고 뒤는 x보다 같거나 크다. 그래서 증가하는 수열의 조건이 계속 유지될 수 있다.  

### 코드  
~~~c++
#include <cstdio>
#include <vector>
#include <climits>

using namespace std;

int main() {

    int N, temp, cnt = 0;
    vector <int> v;

    v.push_back(INT_MIN);

    scanf("%d", &N);

    for (int i = 0; i < N; i++) {
        scanf("%d", &temp);
        if (temp > v.back()) { v.push_back(temp); cnt++; }
        else {
            vector<int>::iterator low = lower_bound(v.begin(), v.end(), temp);
            *low = temp;
        }
    }
    
    printf("%d\n", cnt);

    return 0;
}
~~~