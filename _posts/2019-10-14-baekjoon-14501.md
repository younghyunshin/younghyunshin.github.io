---
layout: post
title: "백준 14501번 : 퇴사"
tags: [알고리즘, 백준, DP]
comments: true
---

> BOJ  

### 문제설명  
상담원으로 일하고 있는 백준이는 퇴사를 하려고 한다.  

오늘부터 N+1일째 되는 날 퇴사를 하기 위해서, 남은 N일 동안 최대한 많은 상담을 하려고 한다.  

백준이는 비서에게 최대한 많은 상담을 잡으라고 부탁을 했고, 비서는 하루에 하나씩 서로 다른 사람의 상담을 잡아놓았다.  

각각의 상담은 상담을 완료하는데 걸리는 기간 Ti와 상담을 했을 때 받을 수 있는 금액 Pi로 이루어져 있다.  

N = 7인 경우에 다음과 같은 상담 일정표를 보자.  
~~~
Ti	3	5	1	1	2	4   2
Pi	10	20	10	20	15	40  200
~~~
1일에 잡혀있는 상담은 총 3일이 걸리며, 상담했을 때 받을 수 있는 금액은 10이다. 5일에 잡혀있는 상담은 총 2일이 걸리며, 받을 수 있는 금액은 15이다.  

상담을 하는데 필요한 기간은 1일보다 클 수 있기 때문에, 모든 상담을 할 수는 없다. 예를 들어서 1일에 상담을 하게 되면, 2일, 3일에 있는 상담은 할 수 없게 된다. 2일에 있는 상담을 하게 되면, 3, 4, 5, 6일에 잡혀있는 상담은 할 수 없다.  

또한, N+1일째에는 회사에 없기 때문에, 6, 7일에 있는 상담을 할 수 없다.  

퇴사 전에 할 수 있는 상담의 최대 이익은 1일, 4일, 5일에 있는 상담을 하는 것이며, 이때의 이익은 10+20+15=45이다.  

상담을 적절히 했을 때, 백준이가 얻을 수 있는 최대 수익을 구하는 프로그램을 작성하시오.  

입력  
첫째 줄에 N (1 ≤ N ≤ 15)이 주어진다.  

둘째 줄부터 N개의 줄에 Ti와 Pi가 공백으로 구분되어서 주어지며, 1일부터 N일까지 순서대로 주어진다. (1 ≤ Ti ≤ 5, 1 ≤ Pi ≤ 1,000)  

출력  
첫째 줄에 백준이가 얻을 수 있는 최대 이익을 출력한다.  

### 접근  
1일부터 시작한다고 이익을 탐색한다고 했을 때 점화식은 다음과 같다.  
~~~
pay[i] = max(pay[i+1], pay[i] + pay[i + time[i]])
~~~

여기서 pay[i] + pay[i + time[i]]는 i번째 날을 선택했을 경우를 의미한다. i번째 날을 선택했으니 당연히 pay[i]는 받을 수 있고 그 다음으로 가장 빨리 할 수 있는 날부터의 최대이익(pay[i + time[i]])도 받을 수 있다. 그런데 이 때 pay[i+1]과 비교하는 이유가 중요하다. 이건 단순히 점화식만 보고는 이해할 수 없고 상담일이 N+1을 초과해서 어차피 선택하지 못하는 날을 어떻게 handle하는지 먼저 이해해야한다. 

다음과 같은 경우를 보자. N = 10인 경우다.  
~~~
Ti	5   4   3   2   1   1   2   3   4   5
Pi	50  40  30  20  10  10  20  30  40  50
~~~
뒤에서부터 배열을 탐색해가며 어차피 선택하지 못하는 날은 0으로 내리고, pay[i]의 값을 pay[i+1]가 아니라 max(pay[i], pay[i + time[i]])의 결과로 업데이트한다고 생각해보자. 아래와 같은 결과를 얻게 된다.  
~~~
Ti	5   4   3   2   1   1   2   3   4   5
Pi	80  70  60  50  40  30  20  30  0   0
~~~
하지만 이 경우의 답은 90이다. 8번째 날에 30, 7번재 날에 20을 받는다. 이 때 7번째 날을 이익이 더 높은 8번째 날로 최대값을 복사해놓지 않으면 6일째부터 잘못된 선택을 하게 되는 것이다. 그러니까 6일째의 이익 + 7일째의 이익(8일째는 선택하지 않음)을 더해도 8일째만 선택하는 경우보다 이익이 적은 상황이 발생하는 것이다. 그래서 8일째까지의 최대이익이 더 크다면 7일째 이익을 그 값으로 업데이트 시켜줘야하는 것이다.  

처음에는 어차피 선택 못하므로 없는 날이나 마찬가지라고 생각해서 얻는 이익을 0으로 바꿔버렸었다. 그런데 이런식으로 하면 문제가 생긴다. 기껏 pay[i+1]의 값이 더 크면 최대값을 한칸씩 복사해왔는데 중간에 선택하지 않는 날이 그냥 0으로 바뀌어버리면 그 이후에는 i+1번째, 즉 지금까지의 최대이익과 비교를 하는게 무의미해져버리는 것이다. 0원으로 바꿔버렸기 때문이다. 그래서 어차피 선택하지 못하는 의미없는 날에는 0으로 이익을 초기화시키는 것이 아니라 지금까지의 최대이익을 그대로 복사해야한다.  

### 코드  
~~~c++
#include <cstdio>
#include <algorithm>

using namespace std;

int main() {

  int time[17] = { 0, };
  int pay[17] = { 0, };
  int n, i;
  int ans = 0;

  scanf("%d", &n);

  for (i = 1; i <= n; i++) scanf("%d %d", &time[i], &pay[i]);

  for (i = n; i >= 1; i--) {
      if (i + time[i] > n + 1) pay[i] = pay[i+1];
      else {
      pay[i] = max(pay[i+1], pay[i] + pay[i+time[i]]);
      ans = max(ans, pay[i]);
    }
  }

  printf("%d\n", ans);

  return 0;
}
~~~