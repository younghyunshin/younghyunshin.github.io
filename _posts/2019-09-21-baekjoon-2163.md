---
layout: post
title: "백준 2163번 : 초콜릿 자르기"
tags: [알고리즘, 백준, DP]
comments: true
---

> BOJ  

### 문제설명  
정화는 N×M 크기의 초콜릿을 하나 가지고 있다. 초콜릿은 금이 가 있는 모양을 하고 있으며, 그 금에 의해 N×M개의 조각으로 나눠질 수 있다.  

초콜릿의 크기가 너무 크다고 생각한 그녀는 초콜릿을 친구들과 나눠 먹기로 했다. 이를 위해서 정화는 초콜릿을 계속 쪼개서 총 N×M개의 조각으로 쪼개려고 한다. 초콜릿을 쪼갤 때에는 초콜릿 조각을 하나 들고, 적당한 위치에서 초콜릿을 쪼갠다. 초콜릿을 쪼갤 때에는 금이 가 있는 위치에서만 쪼갤 수 있다. 이와 같이 초콜릿을 쪼개면 초콜릿은 두 개의 조각으로 나눠지게 된다. 이제 다시 이 중에서 초콜릿 조각을 하나 들고, 쪼개는 과정을 반복하면 된다.  

초콜릿을 쪼개다보면 초콜릿이 녹을 수 있기 때문에, 정화는 가급적이면 초콜릿을 쪼개는 횟수를 최소로 하려 한다. 초콜릿의 크기가 주어졌을 때, 이를 1×1 크기의 초콜릿으로 쪼개기 위한 최소 쪼개기 횟수를 구하는 프로그램을 작성하시오.  

입력  
첫째 줄에 두 정수 N, M(1≤N, M≤300)이 주어진다.  

출력  
첫째 줄에 답을 출력한다.  

### 접근  
초콜릿을 가장 적게 자르는 방법은 매번 반으로 잘라서 모든 조각의 크기가 1 x 1이 될 때 까지 자르는 것이다. 단, 매번 나누기 연산을 계속하는 것이 아니라 DP를 활용하여 이미 계산한 값은 그냥 더해주면 된다. 예를 들어 초콜릿 크기가 12라면 6,6으로 나뉠 것이다. 이 때 6크기를 1까지 만드는데 몇 번 잘라야 하는지 이미 알고있다면 시간을 훨씬 단축시킬 수 있을 것이다.  

그래서 2부터 NM까지 bottom-up approach를 통해 몇번 잘라야 하는지 정보를 기록하고 활용해가며 문제를 풀었다.  

### 코드  
~~~c++
#include <cstdio>

using namespace std;

int main() {

    int i, N, M, a, b, t;

    scanf("%d %d", &N, &M);
    t = N*M;
    int dp[t];
    dp[1] = 0;
    
    for (i = 2; i <= t; i++) {
        a = i/2;
        b = i-a;
        dp[i] = dp[a] + dp[b] + 1;
    }

    printf("%d\n", dp[t]);

    return 0;
}
~~~