---
layout: post
title: "백준 1463번 : 1로 만들기"
tags: [알고리즘, 백준, DP]
comments: true
---

> BOJ  

### 문제설명  
정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.  

1. X가 3으로 나누어 떨어지면, 3으로 나눈다.  
2. X가 2로 나누어 떨어지면, 2로 나눈다.  
3. 1을 뺀다.  
정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.  

입력  
첫째 줄에 1보다 크거나 같고, 10^6보다 작거나 같은 정수 N이 주어진다.  

출력  
첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.  

### 접근  
초기접근  
주어진 수를 2나 3으로 나누었을 때 몫이 2나 3으로 나누어지는 게 가장 좋다.  
만약 그 몫이 2나 3으로 나누어지는 경우가 아니라면 그냥 1을 빼는게 낫다.  
위를 반복한다.  
즉, 10의 경우 10/2 = 5다. 하지만 5는 2로도, 3으로도 나누어지지 않는다. 그러므로 10-1을 한다.  
9/3 = 3이며, 3은 2나 3으로 나눌 수 있다. 그러므로 9/3을 한다.  
3/3 = 1이며 계산이 끝난다.  
즉, 10 -> 9 -> 3 -> 1 의 경우로 1을빼기, 3으로나누기, 3으로 나누기 총 세 번의 연산으로 주어진 N을 1로 만들 수 있다.  

1. 먼저 10^6 (1000001개) 만큼의 boolean type 배열을 만들고 false로 초기화한다.  
2. 2, 3, 6의 배수에 해당하는 index는 모두 true로 바꿔준다.  
3. 주어진 N에 대해서 2로나눈 수를 index로 삼아서 그 배열값이 true라면 실행하고 false라면 1을 뺀다.  
4. N이 1이 될 때 까지 과정3을 반복한다.  
5. cnt변수로 연산의 횟수를 계산한다.  

위 접근에서 고려하지 못한 점 : 단순한 연산 횟수가 아닌 최소 연산 횟수가 중요하다는 것!  
동적 프로그래밍 개념을 좀 더 도입해서 풀어야 한다. bottom-up approach로 문제를 풀면 O(N)번만에 해결할 수 있다.  

2부터 N까지 iterator가 돈다고 할 때, 배열의 값에 해당 index가 1이되려면 해야 하는 최소한의 연산 횟수를 기록해놓을 수 있다.  
예를 들어 반복문 내에서 arr[2] = 1이 기록되어 있다면, arr[4]는 arr[i/2] + 1번을 기록해야한다.  
즉 2로 나눌 때 1번 연산이 필요한건 기록해 두었으니 4를 반으로 나누었을 때의 연산횟수에 1번 더한 만큼 기록하는 것이다.  
먼저 반복문에서 arr[i] = arr[i-1] + 1번으로 기록해 두고 2나 3으로 나누어 떨어지는 경우와 비교한다. 그리고 최솟값을 기록해둔다.  
예를 들어 i가 3일 경우 처음에는 arr[3]은 2일 것이다. (arr[1] = 0이므로) 하지만 실제로 3은 3으로 나누면 한 번에 1로 만들 수 있다. 즉, 현재의 arr[i]와 arr[i/3] + 1 중의 최솟값을 기록해야한다.  

### 코드  
~~~c++
#include <cstdio>

using namespace std;

int min(int a, int b) {
    return a > b ? b : a;
}

int main() {

    int arr[1000001] = {0, };
    int i,N;

    scanf("%d", &N);

    arr[1] = 0;
    for(i = 2; i <= N; i++) {
        arr[i] = arr[i-1] + 1;
        if (i % 2 == 0) arr[i] = min(arr[i], arr[i/2] + 1);
        if (i % 3 == 0) arr[i] = min(arr[i], arr[i/3] + 1);
    }

    printf("%d\n", arr[N]);

    return 0;
}
~~~
