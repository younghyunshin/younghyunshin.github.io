---
layout: post
title: "백준 1965번 : 상자넣기"
tags: [알고리즘, 백준, DP]
comments: true
---

> BOJ  

### 문제설명  
문제  
정육면체 모양의 상자가 일렬로 늘어서 있다. 상자마다 크기가 주어져 있는데, 앞에 있는 상자의 크기가 뒤에 있는 상자의 크기보다 작으면, 앞에 있는 상자를 뒤에 있는 상자 안에 넣을 수가 있다. 예를 들어 앞에서부터 순서대로 크기가 (1, 5, 2, 3, 7)인 5개의 상자가 있다면, 크기 1인 상자를 크기 5인 상자에 넣고, 다시 이 상자를 크기 7인 상자 안에 넣을 수 있다. 하지만 이렇게 상자를 넣을 수 있는 방법은 여러 가지가 있을 수 있다. 앞의 예에서 차례대로 크기가 1, 2, 3, 7인 상자를 선택하면 총 4개의 상자가 한 개의 상자에 들어가게 된다.  

상자의 크기가 주어질 때, 한 번에 넣을 수 있는 최대의 상자 개수를 출력하는 프로그램을 작성하시오.  

입력  
파일의 첫 번째 줄은 상자의 개수 n (1 ≤ n ≤ 1000)을 나타낸다. 두 번째 줄에는 각 상자의 크기가 순서대로 주어진다. 상자의 크기는 1,000을 넘지 않는 자연수이다.  

출력  
첫째 줄에 한 줄에 넣을 수 있는 최대의 상자 개수를 출력한다.  

### 접근  
먼저 DP배열을 하나 선언한다. 그리고 상자의 크기를 담은 배열을 처음부터 탐색하되, i번째 위치의 상자에서 0부터 i-1번째 상자까지 담을 수 있는 상자가 있는지 본다. DP배열은 각 위치의 상자까지 최대 몇 개의 상자를 넣을 수 있는지 정보를 저장한다. 예를 들면 다음과 같다.  
~~~
idx 0 1 2 3 4 5 6 7
arr 1 6 2 5 7 3 5 6
dp  1 2 2 3 4 3 4 5
~~~

arr[4]는 7인데 이 앞의 상자들을 담을 수 있는 경우의 수는 1, 6, 7 혹은 1, 2, 5, 7으로 두 가지 경우가 있다. 만약 인덱스 1번째 상자를 담는다면 크기 1, 6의 상자를 담는 것인데 이 정보가 바로 dp[1] = 2이며 인덱스 1번째 위치의 상자를 선택했을 때 얻을 수 있는 최대값이다. 그러므로 dp[4]를 구하기 위해서는 arr[0]~arr[3]을 탐색하면서 담을 수 있는 상자들에 대해 dp값을 확인하고 더 큰 값을 취하면 된다.  

### 코드  
~~~c++
#include <cstdio>
#include <algorithm>
using namespace std;

int main() {

    int n, i, j, ans = 0;
    scanf("%d", &n);

    int arr[n];
    int dp[n];

    for (i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
        dp[i] = 0;
    }

    dp[0] = 1;
    for (i = 1; i < n; i++) {
        for (j = 0; j < i; j++) {
            if (arr[i] > arr[j]) dp[i] = max(dp[i], dp[j]);
        }
        dp[i]++;
        ans = max(ans, dp[i]);
    }

    printf("%d\n", ans);

    return 0;
}
~~~
