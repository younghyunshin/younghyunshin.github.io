---
layout: post
title: "백준 6603번 : 로또"
tags: [알고리즘, 백준, 순열]
comments: true
---

> BOJ  

### 문제설명  
독일 로또는 {1, 2, ..., 49}에서 수 6개를 고른다.  

로또 번호를 선택하는데 사용되는 가장 유명한 전략은 49가지 수 중 k(k>6)개의 수를 골라 집합 S를 만든 다음 그 수만 가지고 번호를 선택하는 것이다.  

예를 들어, k=8, S={1,2,3,5,8,13,21,34}인 경우 이 집합 S에서 수를 고를 수 있는 경우의 수는 총 28가지이다. ([1,2,3,5,8,13], [1,2,3,5,8,21], [1,2,3,5,8,34], [1,2,3,5,13,21], ..., [3,5,8,13,21,34])  

집합 S와 k가 주어졌을 때, 수를 고르는 모든 방법을 구하는 프로그램을 작성하시오.  

입력  
입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있다. 첫 번째 수는 k (6 < k < 13)이고, 다음 k개 수는 집합 S에 포함되는 수이다. S의 원소는 오름차순으로 주어진다.  

입력의 마지막 줄에는 0이 하나 주어진다.  

출력  
각 테스트 케이스마다 수를 고르는 모든 방법을 출력한다. 이때, 사전 순으로 출력한다.  

각 테스트 케이스 사이에는 빈 줄을 하나 출력한다.  

### 접근  
순열을 이용하면 될 것 같다는 느낌은 있었지만 당최 어떻게 시간제한 내에 중복된 것들 없이 출력할 수 있을까 생각이 들지 않았다. 결국 코드플러스 강의에서 알려준 방법을 힌트삼아 코드를 짰다. 힌트는 "선택한 것은 1, 선택하지 않은 것은 0으로 둔다" 이다.  

단순히 저 문장만 봤을 때 여전히 아리송했다. 생각을 하다가 0과 1로만 이루어진 배열의 모든 순열에 대해 1이 있는 index에 해당하는 집합 S배열의 수를 출력하면 되겠다는 생각이 들었다. 문장이 좀 긴데 다음과 같이 생각하면 된다. 편의상 집합 S를 숫자배열이라고 하겠다.  
~~~
숫자배열  [1 2 3 4 5 6 7]
선택배열  [1 1 1 1 1 1 0], [1 1 1 1 1 0 1], [1 1 1 1 0 1 1] ...
~~~

선택배열의 순열들 중 첫번째는 숫자배열에서 1~6을 선택하고 7을 선택하지 않는 것을 의미한다. 선택배열의 두번째 순열은 1~5와 7을 선택하고 6을 선택하지 않는 것을 의미한다. 즉, 선택배열의 모든 순열에 대해 1이 있는 index의 숫자배열 값을 출력하는 것이다.  

그런데 잘 생각해보면 이렇게 N가지의 순열을 모두 구하는 것은 시간복잡도가 O(N*N!)이다. 이럴 경우, N이 10을 초과하면 1초내에 풀 수 없는 문제가 되고 이 문제의 K는 최대 12인데도 순열 알고리즘 적용이 가능하다. 그 이유는 선택배열에 반드시 6개의 1이, k-6개의 0이 중복해서 들어있기 때문이다. 이런 중복된 경우에 대해서 순열을 구할 때는 시간복잡도가 O(K!/6!K-6!)로 줄어든다.  

### 코드  
~~~c++
#include <cstdio>
#include <algorithm>
using namespace std;

int main() {
  int i, k;

  while (1) {
    scanf("%d", &k);
    if (k == 0) break;

    int choose[12] = { 0, };
    int arr[12];
    for (i = 0; i < 6; i++) choose[i] = 1;
    for (i = 0; i < k; i++) scanf("%d", &arr[i]);

    do {
      for (i = 0; i < k; i++) {
        if (choose[i] == 1) printf("%d ", arr[i]);
      }
      printf("\n");
    } while(prev_permutation(choose, choose+k));

    printf("\n");
  }

  return 0;
}
~~~