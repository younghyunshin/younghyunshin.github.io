---
layout: post
title: "프로그래머스 고득점 kit : 저울"
tags: [알고리즘, 프로그래머스, Greedy]
comments: true
---

> Programmers  

### 문제설명  
하나의 양팔 저울을 이용하여 물건의 무게를 측정하려고 합니다. 이 저울의 양팔의 끝에는 물건이나 추를 올려놓는 접시가 달려 있고, 양팔의 길이는 같습니다. 또한, 저울의 한쪽에는 저울추들만 놓을 수 있고, 다른 쪽에는 무게를 측정하려는 물건만 올려놓을 수 있습니다.  

저울추가 담긴 배열 weight가 매개변수로 주어질 때, 이 추들로 측정할 수 없는 양의 정수 무게 중 최솟값을 return 하도록 solution 함수를 작성해주세요.  

예를 들어, 무게가 각각 [3, 1, 6, 2, 7, 30, 1]인 7개의 저울추를 주어졌을 때, 이 추들로 측정할 수 없는 양의 정수 무게 중 최솟값은 21입니다.  

제한 사항  
- 저울추의 개수는 1개 이상 10,000개 이하입니다.  
- 각 추의 무게는 1 이상 1,000,000 이하입니다.  

### 접근  
ACM-ICPC 2018의 [Black Chain](https://www.acmicpc.net/problem/16282) 문제와 비슷한 문제인 것 같다 (아닐수도..)  

먼저 문제에서 주어지는 무게들을 오름차순 정렬해야 한다. 그리고 배열을 처음부터 탐색하면서 현재 가지고 있는 추의 무게를 보면 되는데 그 추들의 무게를 누적하여 더해가는 값이 탐색한 n번째까지의 추들로 커버할 수 있는 무게의 범위다.  

위의 문제를 예로 들면 [1, 1, 2, 3, 6, 7, 30] 으로 정렬될 것이고 3까지 탐색했다고 했을 때, 1 + 1 + 2 + 3 = 7까지 무게를 나타낼 수 있다. 실제로 1부터 7까지 저 추들로 모두 표현?가능하다. 이렇게 커버할 수 있는 range를 알고있다면 다음 원소는 range+1 보다 작거나 같은 무게여야한다.  

예를 들어 배열이 [1, 2, 4]로 7까지 커버했는데 그 다음 수가 10이라면 8과 9는 영원히 현재 가진 추들로 나타낼 수 없다. 대신 8이 오면 7 + 8 = 15까지의 모든 수를 나타낼 수 있다.  

### 코드  
~~~c++
#include <vector>
#include <cstdio>
#include <algorithm>

using namespace std;

int solution(vector<int> weight) {
    int answer = 0;

    sort(weight.begin(), weight.end());
    answer += weight[0];

    for (int i = 1; i < weight.size(); i++) {
        if (answer+1 < weight[i]) break;
        else answer += weight[i];
    }
    
    return answer+1;
}
~~~