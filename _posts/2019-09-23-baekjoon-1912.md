---
layout: post
title: "백준 1912번 : 연속합"
tags: [알고리즘, 백준, DP]
comments: true
---

> BOJ  

### 문제설명  
n개의 정수로 이루어진 임의의 수열이 주어진다.  
우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다.  
예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 하자. 여기서 정답은 12+21인 33이 정답이 된다.  

입력  
첫째 줄에 정수 n(1 ≤ n ≤ 100,000)이 주어지고 둘째 줄에는 n개의 정수로 이루어진 수열이 주어진다. 수는 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수이다.  

출력  
첫째 줄에 답을 출력한다.  

### 접근  
이 문제는 먼저 틀린 이유를 설명해보겠다.  

~~1. 이 문제는 각각 들어오는 수열의 수들은 -1000 ~ 1000의 사이 수라서 int로 대응 가능하다. 하지만 그 수들의 누적 부분합을 저장하는 dp 배열의 경우 100,000개가 들어오기 때문에 int 범위를 넘어갈 가능성이 있다. long long 타입으로 바꾸어야 한다.~~  

(2020.04.05 수정)  
댓글에 연호박 님이 데이터 범위는 문제가 되지 않는 다는 점을 지적해주셨다. 기존 코드는 ans, dp, arr 모두 long long 타입이었으나 최댓값은 1000이 100000번 들어와도 int로 담을 수 있는데 계산 실수를 했다. 데이터 범위 때문에 틀린 적이 잦았는데 그 문제라고 생각하고 일단 크게 바꾸는 버릇이 당시에 있었던 것 같다 ㅠㅠ 더 정확하게 프로그래밍 하도록 노력해야겠다. 연호박님께 감사드립니다 :)  
2. ans 값을 0으로 초기화하면 보통 max function 으로 최댓값을 구할 수 있으나 이 문제는 수열에 음수가 껴있기 때문에 제대로된 최댓값이 계산되지 않는다.  

부분합을 구하는 대표적인 DP 문제이다.  
1) 직전까지의 부분합과 현재 가리키고 있는 수열의 수를 더한 수, 2) 현재 가리키고 있는 수열의 수를 비교하여 더 큰 값을 부분합으로 저장한다.  
즉, 지금까지 모두 더한 값과 현재 값을 비교했는데 현재 값이 더 크다면 그 이전 수들은 망설임 없이 버리고 새로 시작해도 된다는 뜻이다.  

### 코드  
~~~c++
#include <cstdio>
#include <algorithm>

using namespace std;

int main() {
    int n, i;
    int ans = 0;

    scanf("%d", &n);
    int arr[n];
    int dp[n];

    for (i = 0; i < n; i++) scanf("%d", &arr[i]);
    
    dp[0] = arr[0];
    ans = dp[0];

    for (i = 1; i < n; i++) {
        dp[i] = max(dp[i-1] + arr[i], arr[i]);
        ans = max(ans, dp[i]);
    }
    
    printf("%d", ans);

    return 0;
}
~~~