---
layout: post
title: "백준 15649, 15650, 15651, 15652번 : N과 M 시리즈"
tags: [알고리즘, 백준, 백트래킹]
comments: true
---

> BOJ  

### 문제설명  
백트래킹 기초 네 문제로 조건만 약간씩 바뀌는 문제들이므로 문제설명은 링크로 대신한다.  
[15649번 N과 M(1)](https://www.acmicpc.net/problem/15649)  
[15650번 N과 M(2)](https://www.acmicpc.net/problem/15650)  
[15651번 N과 M(3)](https://www.acmicpc.net/problem/15651)  
[15652번 N과 M(4)](https://www.acmicpc.net/problem/15652)  

### 접근  
백트래킹은 공부해야지 하면서도 예전부터 지레 겁먹고 시도하지 못했던 알고리즘이었다 (왜인지는 모르겠다..)  

아무튼 이 네 문제를 풀면서 백트래킹 기초개념을 잡게 되었다. 백트래킹이란 기본적으로 모든 경우의 수를 탐색하는 것이지만 특정 조건이 만족하는 경우에만 탐색을 하기 때문에 시간복잡도를 줄일 수 있게된다.  

[1, 2, 3]이 주어지고 이 중 세 수를 고르는 수열을 출력한다고 해보자. 단, 수를 중복하여 고를 수 없다. 1~3에 대해서 방문했는지 여부를 체크하는 bool 배열을 하나 둔다. 그리고 1부터 3까지 매번 탐색하며 조건을 만족해서 방문할때마다 true로 업데이트 시키고 출력하기위한 배열에 넣고, 다음단계의 dfs로 넘어간다.  

이 때 "조건을 만족해서"라는 말이 잘 와닿지 않았는데 중복된 수 없이 수열을 나열해야하는 경우 조건이라함은 "아직 방문하지 않은" 수를 의미한다. 예를 들어, 처음에 1을 방문하지 않았을 것이므로 1을 출력하기위한 배열에 넣는다.  

최초에 dfs으로 넘기는 인자는 0이다. 아직 아무것도 출력배열에 넣지 않았다는 것을 의미한다. 1을 방문한 후에는 dfs(1)을 콜한다. 조건에 만족하는 출력가능한 수가 현재까지 1개라는 뜻이다. 이 개수가 m과 같아지면 basecase로 현재까지 쌓여있는 출력용 배열의 수들을 모두 출력한 후 return 한다.  

dfs(3)에서 return을 했다면 dfs(2)로 돌아오게 되는데 이 때 방문중이던 숫자 i를 false로 다시 바꿔주어야한다. 다른 dfs 과정에서 i를 다른 순서로 탐색할 수 있기 때문이다. 다시말해서 [1 2 3]을 출력했다면 dfs(2)로 돌아와서 check[2]를 false로 돌려놓아야 [1 3 2]라는 경우의 수를 다음 dfs 함수에서 카운트할 수 있다.  

### 코드    
~~~c++
#include <cstdio>

using namespace std;

int n, m;
bool check[9] = { false, };
int list[8];

void dfs(int cnt) {
    int i, k;
    if (cnt == m) {
        // 15650번, 15652번 : 오름차순 조건
        for (k = 0; k < m - 1; k++) if (list[k] > list[k+1]) break;
        if (k == m-1) {
            // 15649번 : 기본
            for (i = 0; i < m; i++) {
                printf("%d ", list[i]);
            }
            printf("\n");
        }
        return;
    }
    for (i = 1; i <= n; i++) {
        // 15649번 : 기본
        // 15651번, 15652번 : 같은 수를 여러번 골라도 되는 조건이라면 이 if 조건만 없애주면 된다.
        if (!check[i]) {
            check[i] = true;        
            list[cnt] = i;          
            dfs(cnt+1);             
            check[i] = false;
        }
    }

}

int main() {

    scanf("%d %d", &n, &m);
    
    dfs(0);
    return 0;
}
~~~  