---
layout: post
title: "백준 11722번 : 가장 긴 감소하는 부분 순열"
tags: [알고리즘, 백준, DP]
comments: true
---

> BOJ  

### 문제설명  
수열 A가 주어졌을 때, 가장 긴 감소하는 부분 수열을 구하는 프로그램을 작성하시오.  
예를 들어, 수열 A = {10, 30, 10, 20, 20, 10} 인 경우에 가장 긴 감소하는 부분 수열은 A = {10, 30, 10, 20, 20, 10}  이고, 길이는 3이다.  

입력  
첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.  
둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000)  

출력  
첫째 줄에 수열 A의 가장 긴 감소하는 부분 수열의 길이를 출력한다.  

### 접근  
기초적인 DP 문제라고 하지만 아직 DP 쌩초짜인 나에게는 접근 방식 자체가 떠오르지 않아 여러 포스팅을 참고로 공부하여 풀었다 (아직도 이해 완벽히 되진 않은 듯)  

수열 배열에 가장 먼저 들어온 수는 이후에 수열이 감소할지 증가할지 모르지만 그 자체로 1의 길이를 가진다. 그 길이를 먼저 DP 배열에 1로 기록한다. 새로 들어온 수에 대해서 길이를 판단하기 위해서는 DP 배열에 가리키는 포인터가 두 개 필요하다.  

처음부터 현재 입력 받은 수까지 DP 배열을 탐색하면서 현재 입력된 수가 더 작은지, 그리고 이전 배열의 수의 길이에 1을 더한 값보다 길이가 작은지 검사한다. 두 조건을 모두 만족하면 현재 수(j)의 DP배열 값을 이전 수(i)의 DP배열 값에 1을 더하여 저장한다.  

첫번째 조건은 obvious 하다. 당연히 이전 수보다 현재 수가 작아야 감소 수열의 길이를 1을 더하기 때문이다.  
두번째 조건은 조금 덜 직관적이었다. DP 배열에 저장되어있는 모든 길이와 비교하여 이전의 길이 + 1보다 현재 길이(항상 1)가 작다는 조건은 언뜻 보면 항상 만족한다. 하지만 항상 만족하기 때문에 조건에서 빼야하는 것이 아니다. 이것은 30 - 20 - 10 처럼 길이가 3이상으로 늘어날 때 반드시 체크해야 하는 조건이다. 예를 들면 30의 길이는 1, 20은 2일 것이다. 이 때 10이 들어오면 30과 비교해서 길이가 2가되고, 20과 비교했을 때 둘의 길이가 모두 2일 것이다. 이때 단순히 10이 더 작은 것만 체크하면 안되고 30~20 까지의 감소수열길이에 1을 더하는 과정이 필요하기 때문에 이런 조건이 필요한 것이다.  

### 코드  
~~~c++
#include <cstdio>

using namespace std;

int get_max(int a, int b) { return a > b ? a : b; }
int main() {

    int N, i, j, ans = 0;

    scanf("%d", &N);

    int arr[N];
    int dp[N];

    for (i = 0; i < N; i++) scanf("%d", &arr[i]);
    
    for (i = 0; i < N; i++) {
        dp[i] = 1;
        for (j = 0; j < i; j++) {
            if ( arr[i] < arr[j] && dp[i] < dp[j] + 1 ) dp[i] = dp[j] + 1;
        }
    }

    for (i = 0; i < N; i++) ans = get_max(ans, dp[i]);
    
    printf("%d\n", ans);

    return 0;
}
~~~