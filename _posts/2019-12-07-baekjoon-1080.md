---
layout: post
title: "백준 1080번 : 행렬"
tags: [알고리즘, 백준, Greedy]
comments: true
---

> BOJ  

문제  
0과 1로만 이루어진 행렬 A와 행렬 B가 있다. 이때, 행렬 A를 행렬 B로 바꾸는데 필요한 연산의 횟수의 최솟값을 구하는 프로그램을 작성하시오.  

행렬을 변환하는 연산은 어떤 3*3크기의 부분 행렬에 있는 모든 원소를 뒤집는 것이다. (0 -> 1, 1 -> 0)  

입력  
첫째 줄에 행렬의 크기 N M이 주어진다. N과 M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 행렬 A가 주어지고, 그 다음줄부터 N개의 줄에는 행렬 B가 주어진다.  

출력  
첫째 줄에 문제의 정답을 출력한다. 만약 A를 B로 바꿀 수 없다면 -1을 출력한다.  

### 접근  
최소 횟수에 대한 수학적 증명을 하지 못했지만 그리디라는 믿음으로 제출했는데 AC라서 이게 된다고? 하며 포스팅을 하는 중이다.. 방법은 매우 간단하다. 인덱스를 넘지 않는 범위에서 (0,0)부터 쭉 하나씩 A행렬과 B행렬을 비교해가며 다르면 3 x 3 범위에 대해 flip 한다. 탐색을 마쳤으면 두 행렬이 같은지 비교한다.  

### 코드  
~~~c++
#include <iostream>
#include <string>
#include <vector>

using namespace std;

int n, m, cnt = 0;
vector<string> a;
vector<string> b;

void flip(int x, int y) {
    cnt++;
    int i, j;
    for (i = 0; i < 3; i++) {
        for (j = 0; j < 3; j++) {
            if(a[x+i][y+j] == '0') a[x+i][y+j] = '1';
            else a[x+i][y+j] = '0';
        }
    }
}

int main() {    

    int i, j;
    bool flag = true;
    string s;

    cin >> n >> m;

    for (i = 0; i < n; i++) {
        cin >> s;
        a.push_back(s);
    }

    for (i = 0; i < n; i++) {
        cin >> s;
        b.push_back(s);
    }

    for (i = 0; i < n-2; i++) {
        for (j = 0; j < m-2; j++) {
            if (a[i][j] != b[i][j]) {
                flip(i, j);
            }
        }
    }
    
    for (i = 0; i < n; i++) {
        if (flag) {
            for (j = 0; j < m; j++) {
                if (a[i][j] != b[i][j]) {
                    cout << "-1\n";
                    flag = false;
                    break;
                }
            }
        }
    }
    
    if(flag) cout << cnt << endl;
    
    return 0;
}
~~~