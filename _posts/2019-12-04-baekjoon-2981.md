---
layout: post
title: "백준 2981번 : 검문"
tags: [알고리즘, 백준, 수학]
comments: true
---

> BOJ  

### 문제설명  
트럭을 타고 이동하던 상근이는 경찰의 검문을 받게 되었다. 경찰은 상근이가 운반하던 화물을 하나하나 모두 확인할 것이기 때문에, 검문하는데 엄청나게 오랜 시간이 걸린다.  

상근이는 시간을 때우기 위해서 수학 게임을 하기로 했다.  

먼저 근처에 보이는 숫자 N개를 종이에 적는다. 그 다음, 종이에 적은 수를 M으로 나누었을 때, 나머지가 모두 같게 되는 M을 모두 찾으려고 한다. M은 1보다 커야 한다.  

N개의 수가 주어졌을 때, 가능한 M을 모두 찾는 프로그램을 작성하시오.  

입력  
첫째 줄에 종이에 적은 수의 개수 N이 주어진다. (2 ≤ N ≤ 100)  

다음 줄부터 N개 줄에는 종이에 적은 수가 하나씩 주어진다. 이 수는 모두 1보다 크거나 같고, 1,000,000,000보다 작거나 같은 자연수이다. 같은 수가 두 번 이상 주어지지 않는다.  

항상 M이 하나 이상 존재하는 경우만 입력으로 주어진다.  

출력  
첫째 줄에 가능한 M을 공백으로 구분하여 모두 출력한다. 이때, M은 증가하는 순서이어야 한다.  

### 접근  
문제의 답을 찾는 수학적 접근, 제한된 시간 내에 약수를 나타내는 것 두 측면에서 매우 어려운 문제였다. 여기저기 참고하며 풀었다. 먼저 전자에 대해 설명하면 입력된 수들을 오름차순으로 정렬한 뒤 인접한 수들의 차이들 모두의 최대공약수를 구하고, 그 최대공약수의 약수가 답이 된다. 어째서 그런 것인지.. 수학적인 증명은 아직 잘 모르겠다. 더 생각해봐야지 ㅜㅜ  

정렬과 최대공약수를 구하는 것 까지는 크게 어려운 점이 없었다. 그런데 구해놓은 최대공약수의 약수들을 모두 구하는 과정에서 거의 5번은 넘게 TLE를 받은 것 같다. 약수를 구할 때 2부터 그 수까지 모든 경우의 수를 따지는 것이 가장 먼저 드는 생각이다. 그걸 조금 업그레이드한 버전이 약수를 구하려는 수의 절반까지만 시도해 보는 것이다. 절반을 초과한 수는 절대 약수가 될 수 없기 때문이다. 하지만 이 두가지 버전 모두 문제의 제한사항인 10억이라는 수에는 시간초과일 수 밖에 없다.  

한번 더 생각해볼 수 있는 것이 제곱근까지만 나누어떨어지는지 검사하는 것이다. 예를 들어 100의 약수는 1, 2, 4, 5, 20, 25, 50, 100인데 여기서 1, 2, 4, 5까지만 먼저 구해놓는 것이다. 나머지 수들은 100/1, 100/2, .. 연산으로 바로 알 수 있으니 제곱근 이후의 수들은 검사할 필요가 없다. 그래서 다음과 같은 코드로 구현할 수 있다.  
~~~c++
    for (i = 2; i*i <= n; i++) {
        if (n % i == 0) {
            v.push_back(i);
            v.push_back(n/i);
        }           
    }
    v.push_back(n);
~~~
여기서 마지막에 n자체를 벡터에 넣어주는 것을 잊지 말아야 한다. (혹은 벡터값들을 출력한 뒤 마지막에 n을 출력해주자)  
그리고 문제의 조건에 맞게 오름차순 정렬한 후 중복값들을 제거해주면 된다.  

### 코드  
~~~c++
#include <cstdio>
#include <algorithm>
#include <vector>

using namespace std;

int gcd(long long a, long long b) {
    return b ? gcd(b, a%b) : a;
}

int main() {

    int N, i, t;
    long long n;
    vector<int> v;

    scanf("%d", &N);
    long long arr[N];
    for (i = 0; i < N; i++) scanf("%lld", &arr[i]);

    sort(arr, arr + N);

    n = arr[1] - arr[0];
    for (i = 2; i < N; i++) {
        n = gcd(n, arr[i] - arr[i-1]);
    }

    for (i = 2; i*i <= n; i++) {
        if (n % i == 0) {
            v.push_back(i);
            v.push_back(n/i);
        }           
    }

    v.push_back(n);
    sort(v.begin(), v.end());
    v.erase(unique(v.begin(), v.end()), v.end());

    for(i = 0; i < v.size(); i++) printf("%d ", v[i]);
    printf("\n");
    return 0;
}
~~~