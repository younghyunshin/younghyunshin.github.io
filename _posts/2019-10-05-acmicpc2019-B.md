---
layout: post
title: "ACM-ICPC 2019 Problem B : Balanced String"
tags: [알고리즘, 대회, ACM-ICPC]
comments: true
---

> ACM-ICPC 2019 Aisa Seoul National First Round  

### 문제설명  
문제
0과 1로 이루어진 이진 문자열 0101101은 0과 1의 개수의 차이가 1 이하이다. 뿐만 아니라, 첫번째 문자를 포함하는 모든 부분 문자열 0, 01, 010, 0101, 01011, 010110, 0101101 모두 0과 1의 개수의 차이가 1 이하이다.  

이와 같이, 이진 문자열 중에서 첫번째 문자를 포함하는 모든 부분 문자열의 0과 1의 개수의 차이가 1이하인 문자열을 균형잡힌 문자열이라 부른다. 문자열 자체도 자신의 부분 문자열이다.  

양의 정수 n 이 주어질 때, 길이가 n 인 이진 문자열 중에서 균형잡힌 문자열의 수를 구하는 프로그램을 작성하시오.  

예를 들어, n = 3인 경우에는 010, 011, 100, 101 네 개의 문자열이 균형잡힌 문자열이다.  

입력  
입력은 표준입력을 사용한다. 첫 번째 줄에 양의 정수 n (1 ≤ n ≤ 100,000)이 주어진다.  

출력  
출력은 표준출력을 사용한다. 길이가 n 인 이진 문자열 중에서 균형잡힌 문자열의 개수를 16769023로 나눈 나머지 값을 한 줄에 출력한다.  

### 접근  
이 문제는 대회 때 윤호형이 풀어서 대회 끝나고 내가 직저 풀어봤다.  

균형잡힌 문자열이 첫 문자를 포함한 모든 부분문자열에 대해 적용되는 경우를 자세히 살펴보면 규칙을 찾을 수 있다.  
~~~
n == 1 or 2 : 2가지  
n == 3 or 4 : 4가지  
n == 5 or 6 : 8가지
...
~~~

이렇게 나오는 이유는 간단하다. 길이가 홀수가 되는 순간에는 0과 1이 모두 올 수 있지만 짝수 길이가 되는 때에는 0과 1 중 하나만 올 수 있다. 무슨말인가 하면..  
~~~
n = 1일 때 0 혹은 1만 가능하다.  
n = 2일 때 0에서 가능한 경우는 00과 01중 01만 가능하다.  
n = 3일 때 01에서 가능한 경우는 010, 011 모두 가능하다. 마찬가지로 10에서 가능한 경우는 101, 100 모두 가능하다.  
~~~

이걸 일반화 해보면 n이 짝수일 때 2의 n/2승, 홀수일때는 2의 n/2+1승개다.  

### 코드  
~~~c++  
#include <cstdio>
#include <cmath>
using namespace std;
#define MOD 16769023

int main() {
    long n, ans = 1;
    scanf("%ld", &n);
    for (int i = 1; i <= n/2; i++) { ans *= 2; ans %= MOD; }
    if (n % 2 != 0) ans *= 2;
    printf("%ld\n", ans%MOD);
    return 0;
}
~~~