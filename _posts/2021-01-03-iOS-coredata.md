---
layout: post
title: "iOS) 코어데이터 알아보기"
tags: [iOS, Swift]
comments: true
---

> Core Data  

⚠ iOS알못의 글이므로 틀린 정보가 있을 수 있습니다.  

## 코어데이터란?

코어데이터는 애플의 `local object graph persistence framework`로 로컬 디바이스에 데이터를 저장하는 목적으로 사용된다. 오늘은 코어데이터는 무엇이며, 어떻게 이루어져있고 어떤 기능을 지원하는지 알아보자.

코어데이터란 `객체지향 데이터베이스`를 위한 거대한 프레임워크이다. 단순히 배열이나 리스트가 아닌 체계적인 데이터베이스를 관리해야할 때 필요하다. 헷갈리지 말아야할 것은 밖에서 보기에는 객체지향 데이터베이스지만 내부는 관계형 데이터베이스(relational database)라는 것이다. 주로 데이터를 처리하는 건 관계형 데이터베이스 중에서도 SQL 기반이다. 하지만 SQL에 대해 알 필요는 없다. 객체를 다룰 수 있으면 된다.

## 코어데이터 == 데이터베이스?

방금 코어데이터는 내부는 관계형 데이터베이스라고 했다. 이렇게만 설명을 마치면 코어데이터 == 데이터베이스라는 일종의 공식같은 생각을 하게되는데 이는 올바른 이해가 아니다. 정확히 하자면 코어데이터는 데이터베이스가 아니며 코어데이터의 기능 중 하나인 Persistence가 관계형 데이터베이스인 SQLite에 의해 지원되는 것이다. 이 말은 곧 데이터베이스의 기능을 코어데이터가 지원하기도 하고 SQLite에 없는 코어데이터만의 고유 기능을 갖고 있기도 하다는 뜻이다.

다시 정리하자면 **코어데이터는 애플리케이션의 모델 계층의 객체를 관리하는데 사용하는** `프레임워크`**이자 객체의 라이프 사이클이나 영속성 관리를 위한 기능을 제공하는** `객체 그래프 관리자`이다. "객체 그래프"라는 단어에서 알 수 있듯 외부에서 보기에는 Object-Oriented Database의 형태를 띄고 있지만 그 내부에는 SQLite Database처럼 기능하고있다. (XML Store Type, In-Memory Store Type도 있다. SQLite은 그 중 하나일 뿐)

*객체 그래프 관리자라는 단어는 아래에서 더 자세히 설명하겠다.

## CoreData vs. Database

먼저 `데이터베이스`의 주된 기능에 대해 생각해보자. 데이터베이스는 **영속적이고 검색 가능한 테이블 구조의 행/열로 구성된 데이터저장소**라고 생각할 수 있다. 이 저장소의 목적은 **디스크에 항상 최신의 데이터를 저장하는 것과 데이터를 불러오고 업데이트 하는 것**이다. 많은 데이터베이스들이 관계형이라고 불리지만 SQLite와 많은 다른 관계형 데이터베이스들은 실제로 객체들의 직접적 연결을 다루지는 않는다. 테이블간의 행/열에 관한 관계를 유지하는 것은 데이터베이스를 사용하는 사용자가 해야한다. 이러한 관점에서 데이터베이스는 "멍청한(dumb)" 저장소이다. 테이블의 열을 다룰 경우 읽기/쓰기 이상의 동작이 거의 전부이고 이를 확장하거나 커스터마이징 하기 위해서는 결국 데이터베이스 시스템 자체를 확장하게 될 수 밖에 없다.

그렇다면 `코어데이터`의 주된 기능은 무엇일까? 코어데이터의 본질은 라이프사이클, 검색, 영속성 기능을 가진 객체 그래프 관리자(object graph manager)이다. 객체 그래프 관리는 아래 기능들을 의미한다:

- 객체 A를 객체 B와 연결할 수 있으며, 해당 연결은 영속적으로 동기화 된다. (A쪽에서 연결을 변경하면, B가 업데이트 되면서 그에따른 알림(notification)을 발생시킨다. 그리고 이 알림에 대해 임의의 코드를 짜넣어서 실행하는 것이 가능하다)
- 한쪽에서 객체를 삭제할 경우 연결을 타고 cascade 삭제가 일어나도록 할수도있고, nullify 시켜서 해당 객체만 삭제 할 수도 있다.

보통의 데이터베이스들과는 다르게 코어데이터는 완전한 `인메모리(in-memory)` 형태로 사용이 가능하다. 일반적으로 사용자들이 영속성 특성을 대부분 사용하기 때문에 코어데이터가 “객체 영속성(object persistence)” 프레임워크라고 불리지만, 실제로는 어떠한 형태의 영속성도 지니지 않은 in-memory형태로 사용하는 것이 가능한 것이다. 즉, 코어데이터를 사용할때 “영속성”이 의무적인 기능이 아니란 것을 알아두는 것이 중요하다.

또한 코어데이터를 어떠한 형태의 검색기능 없이도 사용가능하다. 일단 객체들이 할당되고 연결되었을 경우, 한 객체에만 접근이 가능하다면, 추가적인 불러오기(fetch) 없이 해당 객체로부터 나머지 연결된 객체들을 타고 넘어가면서 접근이 가능하다. 일단 데이터들이 메모리에 로딩되면, 연결고리를 따라 이동하는 것은 검색 없이도 가능하기 때문에 코어데이터가 이러한 `비검색(seachless)` 특성을 갖게된다.

모든 코어데이터 객체들은 `완전히 인스턴스화된(fully instantiated)` Objective-C 객체이며 속성값과, 관계, 라이프사이클을 관리하는 것이 가능하다. 이것은 또한 객체들의 속성들(property)과 동작들이 메서드(method)에 의해 구현될 수 있음을 의미하며, 이러한 메서드들은 서브클래싱을 통해 옵저브와 오버라이드가 가능하다(observable & overridable).

## CoreData vs. UserDefaults

`UserDefaults`는 데이터베이스 없이 데이터를 key-value 형태로 저장하기에 가장 쉬운 방법이다. 이 접근은 적은 양의 데이터를 저장하기에 매우 적합하다. 대부분의 경우, 유저디폴트는 user setting, user's preferences와 같은 critical하지 않은 정보를 저장하는데 사용된다. critical 하지 않은 정보만 저장하도록 권장하는 이유는 유저디폴트는 암호화되어 저장되는 storage가 아니기 때문이다. 또한, 유저디폴트가 큰 양의 데이터를 저장하기에 적합하지 않은 이유는 앱 시작과 함께 요청하지 않은 정보에 대해서도 모두 메모리에 로드하기 때문이다. 애플 공식문서에 따르면 "UserDefaults caches the information to avoid having to open the user’s defaults database each time you need a default value"라고 한다. 이와 달리 코어데이터는 필요한 정보에 대해서만 fetch해 온다는 점에서 더 많은 데이터를 저장하는 경우에 용이하다는 것을 알 수 있다.

`CoreData`는 마찬가지로 영구저장소의 역할을 한다. 위에서 설명한대로 SQLite 데이터베이스 기반으로 객체지향, 관계형 데이터베이스를 제공하며 on-disk, in-memory 등 저장방식을 선택할 수도 있다. 많은 양의 데이터베이스를 객체지향적으로, 즉 객체 그래프의 형태로 관리하기에 용이하다. 만약 random, unrelated data pieces라면 코어데이터보다는 유저디폴트가 맞을 것이다. 유저디폴트와 다른 점은 코어데이터의 경우 필요한 정보에 대해서만 fetch 해오지만 유저디폴트는 property list를 메모리에 로드한다는 점이다. 코어데이터는 러닝커브가 높다는 점과 오버헤드의 발생이 단점이다.

## 객체 그래프 관리자

위에서 몇번이나 객체 그래프 관리자라는 단어가 나왔다. 아래 사진을 보면 왜 객채 그래프(object graph) 라는 용어가 나왔는지 알 수 있다. **메모리에 객체들이 여러 relationship으로 엮여있는 것을 객체 그래프**라고 하고, 이 형태를 그대로 코어데이터의 컨테이너에 저장시키기 때문이다.

![1](https://user-images.githubusercontent.com/35067611/105619063-337ae580-5e32-11eb-990f-b8e6e1b560e7.png)

아마 이 사진을 봤을 때 `context`는 뭔가 싶을 수 있다. 이는 아래 코어데이터의 구성에서 자세히 설명하도록 하겠다. 일단 코어데이터가 위와 같은 단계를 거쳐 객체 그래프를 관리한다고만 알아두자.

## 코어데이터의 구성

지금까지 코어데이터는 무엇이며, 데이터베이스와 어떻게 다르고 어떤 기능적 지원을 하는지 알아보았다. 그렇다면 실제로 코어데이터를 활용하기 위해 어떤 요소들로 이루어져있는지 살펴보자.

![2](https://user-images.githubusercontent.com/35067611/105619065-3a095d00-5e32-11eb-8b5c-61308dc0208b.png)

**1) 관리 객체(Managed Obejct) : NSManagedObject**

데이터베이스 안에 있는 것들의 타입이 NSManagedObject로 테이블에서 레코드를 읽을 때 코어데이터에서는 객체가 생성되는데, 이 객체를 저장하는 자료형이다.

예) 직원들의 데이터를 다룰 때 DB에서 직원들의 정보를 읽어오면 이것을 그대로 사용하지 않고 VO(Value Object)인스턴스에 담아 사용, 이때 VO가 관리 객체에 해당

**2) 관리 객체 컨텍스트(Managed Object Context) : NSManagedObjectContext**

NSManagedObjectContext는 데이터베이스를 대표하며 모든 코어데이터 활동이 이루어지는 `허브`와도 같은 곳이다. 그리고 코드로 이 context에 접근하기 위해서 NSPersistentContainer가 필요하다.

컨텍스트의 핵심적인 두 가지 역할

(1) Managed Object를 가지고 CRUD역할 (Core Data에서 생성되는 모든 관리 객체는 컨텍스트에 담겨 관리)

- 컨텍스트에 담긴 객체는 영구 저장소로 보내 저장, 삭제 가능
- 코더데이터는 메모리에 로드된 상태로 처리되는데, 이 때의 메모리가 "컨텍스트"를 의미

(2) "영구 저장소"와 "영구 저장소 코디네이터"에 대한 관리자 역할

- 읽기와 쓰기를 영구 저장소에 요청 (DAO패턴과 유사)

`viewContext`는 NSManagedObjectContext 중에서도 메인 스레드에서만 사용할 수 있는 변수이다. 메인큐에서만 사용되는 이 변수의 이름이 viewContext인 이유는 UIView와 함께 사용되기 때문이다. 메인큐에서만 사용한다는 것이 중요한 것은 NSManagedObjectContext가 **thread safe하지 않기 때문**이다. 코어데이터의 스레드 안전성에 대해서는 아래에서 다루겠다.

**3) 영구 저장소 코디네이터(Persistent Store Coordinator)**

컨텍스트와 직접 데이터를 주고 받으면서 다양한 영구 저장소들의 접근을 조정하고 입출력을 담당

흐름 : 컨텍스트가 데이터 요청 -> 코디네이터가 요청을 받고, 영구 저장소에서 데이터 탐색 -> 코디네이터가 Managed Object 인스턴스 생성하여 반환

**4) 관리 객체 모델(Managed Obejct Model)**

엔터티(Entity)의 구조를 정의하는 객체인 동시에 이를 바탕으로 Managed Object패턴의 모델 클래스를 참조

Managed Object vs. Managed Object Model

- Managed Object Model : 클래스이자 형식이고 구조를 의미, 데이터를 CRUD하지 않으며 관리 객체의 각 요소를 제대로 담을 수 있도록 저장 데이터를 구조화
- Mnaged Object : Managed Object Model을 바탕으로 생성된 인스턴스

**5) 영구 객체 저장소(Persistent Obejct Store)**

초기에는 직접 읽을 수 있으며 디버깅에 용이한 XML저장소 타입을 사용하며, 앱을 배포할 당시 대량의 데이터를 고려하여 SQLite데이터베이스를 사용하는 것이 용이

## 코어데이터와 Thread Safe

코어데이터의 스레드 안전성에 대해 알아보자. 데이터베이스에서 다뤄지는 모든 것들은 thread safe하지 않다. context는 자신한테 생성된 큐에서만 생성될 수 있다. 만약 context를 다른 큐에 넘기게 되면 작동하지 않을 것이다. context 뿐 아니라 해당 context에서 생성한 모든 데이터도 동일한 큐에서 처리되어야한다. 일반적으로 코어데이터도 빠르지만 데이터를 로드해오는 것은 메인에서 하지 않는 것이 더 좋다.

이를 위해 데이터베이스가 멀티 스레드로 작동하도록 하는 것이다. 각각의 데이터베이스가 여러 context를 가질 수 있는데 완전히 다른 context는 각각 다른 큐에 있더라도 동일한 데이터베이스에 기록할 수 있다. 그렇다면 어떻게 context를 여러 큐에 넣을 수 있을까?

`performBlock` 메소드를 알아보자. 이 메소드는 정의된 클로저가 올바른 큐에서 작동한다는 것을 보장해주는 메소드이다. 여러 큐에 여러 context를 넣기 위해서는 이 메소드를 사용해주어야 스레드 안정성을 지킬 수 있을 것이다. 하지만 다른 스레드에 있는 context를 가져오는 것은 어떻게 할 수 있을까? 이 방법으로는 해결할 수 없는 문제다.

persistentContainer에는 `performBackgroundTask`라는 코어데이터에서 백그라운드 작업을 할 수 있도록 하는 메소드가 있다. 이 메소드는 메인큐가 아닌 다른 큐를 찾아 context를 생성하고 클로저에 들어있는 내용을 수행하도록한다. **이 때 클로저 내부에서는 절대 viewContext를 사용해서는 안된다.** 이 클로저는 메인 큐에서 돌아가지 않는데 viewContext는 메인 큐에서 사용되기 때문이다. 그리고 반드시 저장해야한다. 이렇게 백그라운드 스레드에서 실행될 클로저에서도 저장을 하고 나면 viewContext에서도 동일한 데이터베이스의 업데이트 사항에 대해 올바르게 접근하게된다.

## 한계

코어데이터는 데이터베이스가 아니라고 했는데, 데이터베이스에서는 할 수 있지만 코어데이터가 하지 못하는 작업에 대해 생각해볼 수 있다.

`코어데이터는 데이터들을 메모리에 로딩하는 과정 없이는 작업할 수 없다.`

SQL구문에서 테이블을 삭제하거나 레코드들을 업데이트하기 위해서 “DROP tableName” 이나 “UPDATE tableName SET key1 = value WHERE key2 = otherValue” 명령이 이용된다. 명령 처리를 위해서 각 레코드에 해당하는 작은 크기의 데이터만 메모리에 로드를 하면 되기때문에, 데이터의 양이 많더라도 효율적으로 업데이트가 가능하다. 하지만 코어데이터는 메모리상의 객체를 수정하는것만이 가능하기 때문에 이러한 온디스크(on-disk) 방식의 사용이 불가능하다. 심지어 코어데이터는 객체를 삭제 할 때도, 일단 인스턴스화 시켜서 메모리에 로드를 먼저 해야 삭제가 가능하다. 객체에 추가적으로 오버라이드된 동작들이 로드되고 실행되기 위해서, 그리고 다른 객체와의 연결정보를 최신으로 유지하기 위해서는 이러한 메모리 로드작업이 필수적일 수밖에 없다.

`코어데이터는 데이터 로직을 다루지는 않는다.`

SQL에 존재하는 저장되는 데이터를 제약할 수 있는 unique key 같은 기능이 코어데이터에는 포함되어있지 않다. 코어데이터로부터 생성된 모델클래스를 상속받아서 사용할경우, 코어데이터의 attribute에대해 getter/setter를 오버라이드 할 수 있다보니 코어데이터 입장에서는 이것이 unique key 인지 아닌지 알 수가 없다. 결국 이러한 제약조건들이 코어데이터에서 제어가능한 도메인 밖에 있다보니 모델에 적용하려면 애플리케이션 레벨에서 직접 비지니스 로직상에서 따로 구현해야 한다.

## References

[제드님 블로그 - Core Data (1)](https://zeddios.tistory.com/987)

[[iOS - swift] 12. 코어 데이터(Core Data)의 개념 - (1)](https://ios-development.tistory.com/89)

[코어데이터(Core Data)와 데이터베이스의 차이](https://www.letmecompile.com/코어데이터core-data와-데이터베이스의-차이/)

[한글링 유튜브 - 코어데이터를 구성하자](https://www.youtube.com/watch?v=q5CwqHvDI7E&list=PLE0Is7fZwoLA9M6fdCFsfdlG--OK_bF78)
