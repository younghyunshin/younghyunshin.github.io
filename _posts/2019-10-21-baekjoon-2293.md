---
layout: post
title: "백준 2293번 : 동전 1"
tags: [알고리즘, 백준, DP]
comments: true
---

> BOJ  

### 문제설명  
n가지 종류의 동전이 있다. 각각의 동전이 나타내는 가치는 다르다. 이 동전을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고 싶다. 그 경우의 수를 구하시오. 각각의 동전은 몇 개라도 사용할 수 있다.  

사용한 동전의 구성이 같은데, 순서만 다른 것은 같은 경우이다.  

입력  
첫째 줄에 n, k가 주어진다. (1 ≤ n ≤ 100, 1 ≤ k ≤ 10,000) 다음 n개의 줄에는 각각의 동전의 가치가 주어진다. 동전의 가치는 100,000보다 작거나 같은 자연수이다.  

출력  
첫째 줄에 경우의 수를 출력한다. 경우의 수는 2^31보다 작다.  

### 접근  
1원을 만드는 방법은 1원 동전을 사용하는 1가지 경우밖에 없다.  
2원을 만드는 방법은 1원 동전 2개를 사용하거나 2원 동전 1개를 사용하는 두 가지 경우가 있다. 이것은 1원을 만드는 경우의 수에 2원 동전 하나만 사용하는 한 가지 경우를 추가하는 것과 같다.  
5원을 만드는 방법은 5원(1개), 1원(3개) + 2원(1개), 1원(1개) + 2원(2개), 1원(5개)로 총 네 가지 경우가 있다. 이것은 4원을 만드는 경우의 수에 5원 동전 하나만 사용하는 한 가지 경우를 추가하는 것과 같다.  

좀 더 자세히 이해하기 위해 dp 배열의 변화를 살펴보자  
~~~
idx 0   1   2   3   4   5   6   7   8   9   10  (k)
dp  1   0   0   0   0   0   0   0   0   0   0   (초기화)
dp  1   1   1   1   1   1   1   1   1   1   1   (1만 사용하여 k를 만들 수 있는 경우의 수)
dp  1   1   2   2   3   3   4   4   5   5   6   (1과 2를 사용하여 k를 만들 수 있는 경우의 수)
dp  1   1   2   2   3   4   5   6   7   8   10  (1, 2, 5를 모두 사용하여 k를 만들 수 있는 경우의 수)
~~~

현재 coins[i]가 5라면, 어차피 5원 미만의 k는 추가될 경우의 수가 없다. 대신 5이상의 k에 대해서는 5원을 사용하는 경우를 하나씩 추가해주어야 한다. 이 때 단순히 1을 더하는 것이 아니라 다음과 같은 경우를 따져서 더한다.  
~~~
5원 = 0원 + 5원 (coins[i] = 5일때)
5원 = 3원 + 2원 (coins[i] = 2일때)
5원 = 4원 + 1원 (coins[i] = 1일때)
...

dp[j] = dp[j](기존의 동전 종류를 이용해 k를 만드는 경우의 수) + dp[j - coins[i]](새 동전 종류 사용하는 경우 추가)
~~~


### 코드  
~~~c++
#include <cstdio>
using namespace std;

int main() {

    int i, j, n, k;
    int dp[10001] = {0, };

    scanf("%d %d", &n, &k);

    int coins[n];

    for (i = 0; i < n; i++) scanf("%d", &coins[i]);
    
    dp[0] = 1;
    for (i = 0; i < n; i++) for (j = coins[i]; j <= k; j++) if (j - coins[i] >= 0) dp[j] += dp[j - coins[i]];

    printf("%d\n", dp[k]);
    return 0;
}
~~~