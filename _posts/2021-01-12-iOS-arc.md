---
layout: post
title: "iOS) ARCì— ëŒ€í•´ì„œ"
tags: [iOS, Swift]
comments: true
---

> ë©”ëª¨ë¦¬ ê´€ë¦¬ ì•Œì•„ë³´ê¸°  

âš  iOSì•Œëª»ì˜ ê¸€ì´ë¯€ë¡œ í‹€ë¦° ì •ë³´ê°€ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.  

Swift Language Guide ë¬¸ì„œì—ì„œ ARCë¥¼ ì°¾ì•„ë³´ë©´ ì´ë ‡ê²Œ ë‚˜ì˜¨ë‹¤.

Swift uses Automatic Reference Counting (ARC) to track and manage your appâ€™s memory usage. In most cases, this means that memory management â€œjust worksâ€ in Swift, and you do not need to think about memory management yourself. ARC automatically frees up the memory used by class instances when those instances are no longer needed.

ë¸”ë¼ë¸”ë¼.. you do not need to think about memory management yourself!? ìŠ¤ìœ„í”„íŠ¸ëŠ” ë‚´ê°€ ë©”ëª¨ë¦¬ ê´€ë¦¬ì— ì „í˜€ ì‹ ê²½ì“°ì§€ ì•Šê³  ì½”ë”©í•  ìˆ˜ ìˆëŠ” ì–¸ì–´êµ¬ë‚˜! NOPEğŸ™…ğŸ» ê·¸ë ‡ì§€ ì•Šë‹¤! ì˜¤íˆë ¤ ARCì˜ ë©”ì»¤ë‹ˆì¦˜ì„ ì œëŒ€ë¡œ ì´í•´í•˜ê³  Xcodeê°€ ì—ëŸ¬ë¡œ ë„ì›Œì£¼ì§€ ì•ŠëŠ” memory leak ê°™ì€ ì˜¤ë¥˜ë¥¼ ë””ë²„ê¹… í•  ìˆ˜ ìˆì–´ì•¼í•œë‹¤. ê·¸ëŸ¬ë‹ˆ ì˜¤ëŠ˜ì€ ARCì— ëŒ€í•´ ì•Œì•„ë³´ì!

## Definition

ARCëŠ” `Automatic Reference Counting`ì˜ ì¤„ì„ë§ë¡œ ê·¸ëŒ€ë¡œ í•´ì„í•´ë³´ë©´ ìë™ ì°¸ì¡° ì¹´ìš´íŒ…(?)ì´ë‹¤.

ì°¸ì¡°ëŠ” ë³´í†µ í´ë˜ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ê°€ë¦¬í‚¬ ë•Œ, í´ë¡œì €ë¥¼ assign í–ˆì„ ë•Œ ë“±ë“± ì“°ì´ëŠ”ë° ì´ ì°¸ì¡°ë“¤ì˜ ê°œìˆ˜ë¥¼ ì„¸ëŠ”ê²Œ ë©”ëª¨ë¦¬ì™€ ë¬´ìŠ¨ ê´€ë ¨ì´ ìˆì„ê¹Œ? ì°¸ì¡° ì¹´ìš´íŒ…ê³¼ ë©”ëª¨ë¦¬ê´€ë¦¬ì˜ ì—°ê´€ì„±ì„ ì•Œê¸° ìœ„í•´ì„œëŠ” Swift ì–¸ì–´ê°€ ë³€ìˆ˜, ì¸ìŠ¤í„´ìŠ¤, í´ë¡œì € ë“±ì„ ë©”ëª¨ë¦¬ì—ì„œ í•´ì œí•˜ê¸°ìœ„í•œ ì¡°ê±´ì„ ì´í•´í•´ì•¼í•œë‹¤.

## Reference Counting â†” Memory Management â“

ìš°ë¦¬ê°€ í´ë˜ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ë¥¼ í•˜ë‚˜ ìƒì„±í•˜ë©´ ARCëŠ” ì´ ì¸ìŠ¤í„´ìŠ¤ì˜ íƒ€ì…ê³¼ ë‚´ë¶€ì˜ ì†ì„±ë“¤ì˜ ì •ë³´ë¥¼ hold í•˜ëŠ” ë©”ëª¨ë¦¬ë¥¼ í• ë‹¹(memory allocation)í•œë‹¤. ê·¸ë¦¬ê³  ë” ì´ìƒ í•„ìš”ê°€ ì—†ì–´ì§€ë©´ ë©”ëª¨ë¦¬ì—ì„œ í•´ì œí•œë‹¤(deallocation). í•˜ì§€ë§Œ ì—¬ì „íˆ ì“°ì—¬ì•¼ í•˜ëŠ”ë° ë©”ëª¨ë¦¬ì—ì„œ í•´ì œë˜ë©´ ì ‘ê·¼í•  ë°©ë²•ì´ ì—†ì–´ì§„ë‹¤. ì´ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ARCëŠ” ì¸ìŠ¤í„´ìŠ¤ë¥¼ ê°€ë¦¬í‚¤ëŠ” ì°¸ì¡°ê°€ ëª¨ë‘ ì‚¬ë¼ì¡Œê³  ë” ì´ìƒ ì‚¬ìš©ë˜ì§€ ì•Šì„ ë•Œ ë¹„ë¡œì†Œ ë©”ëª¨ë¦¬ì—ì„œ í•´ì œí•œë‹¤. ì—¬ê¸°ì„œ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ê°€ë¦¬í‚¤ëŠ” ì°¸ì¡°ëŠ” íŠ¹ë³„í•œ í‚¤ì›Œë“œ ì§€ì •ì´ ì—†ë‹¤ë©´ ê¸°ë³¸ì ìœ¼ë¡œ(default) ê°•í•œì°¸ì¡°(strong reference)ì´ë‹¤.

ì˜ˆë¥¼ ë“¤ì–´ Personì´ë¼ëŠ” í´ë˜ìŠ¤ê°€ ìˆê³ , ì•„ë˜ì™€ ê°™ì´ í´ë˜ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•´ì„œ ê°€ë¦¬í‚¤ëŠ” ë³€ìˆ˜ë“¤ì„ ì„ ì–¸í–ˆë‹¤ê³  í•˜ì. ê·¸ë¦¬ê³  ì´ í´ë˜ìŠ¤ëŠ” init, deinit ë  ë•Œ ë©”ì„¸ì§€ë¥¼ ì¶œë ¥í•œë‹¤.

```swift
var reference1: Person?
var reference2: Person?
var reference3: Person?

reference1 = Person(name: "John Appleseed") // "John Appleseed is being initialized"
reference2 = reference1
reference3 = reference1
```

ì´ ê²½ìš° Person í´ë˜ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ëŠ” í•œë²ˆ init ëì§€ë§Œ ì„¸ ê°œì˜ strong referenceê°€ í–¥í•˜ê³ ìˆë‹¤. ê·¸ë˜ì„œ ì´ ì„¸ ë³€ìˆ˜ë¥¼ ëª¨ë‘ nilë¡œ ë°”ê¿”ì¤„ ë•Œ ë¹„ë¡œì†Œ deinitì´ ë¶ˆë¦°ë‹¤.

```swift
reference1 = nil
reference2 = nil
reference3 = nil // "John Appleseed is being deinitialized"
```

ì´ì œ reference countingê³¼ memory mangementê°€ ì–´ë–¤ ê´€ê³„ê°€ ìˆê³ , ARCê°€ ì°¸ì¡°ì˜ ê°œìˆ˜ë¥¼ ë©”ëª¨ë¦¬ ê´€ë¦¬ì— ì–´ë–»ê²Œ í™œìš©í•˜ëŠ”ì§€ ì´í•´í–ˆìœ¼ë‹ˆ ë³¸ê²©ì ìœ¼ë¡œ ë°œìƒí•  ìˆ˜ ìˆëŠ” ë¬¸ì œì— ëŒ€í•´ ë‹¤ë¤„ë³´ì.

## Strong Reference Cycles

ìœ„ì˜ ì˜ˆì‹œ ì½”ë“œì—ì„œëŠ” ì •ìƒì ìœ¼ë¡œ ARCë¥¼ 0ìœ¼ë¡œ ë§Œë“¤ ìˆ˜ ìˆì—ˆë‹¤. í•˜ì§€ë§Œ Swiftë¡œ í”„ë¡œê·¸ë˜ë°ì„ í•˜ë‹¤ë³´ë©´ ì ˆëŒ€ ARCê°€ 0ì´ ë  ìˆ˜ ì—†ëŠ” ìƒí™©ì— ë†“ì´ëŠ” ê²½ìš°ê°€ ì¢…ì¢… ìˆë‹¤. í´ë˜ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ ê°„ì˜ ìƒí˜¸ì°¸ì¡°ê°€ ë°”ë¡œ ê·¸ê²ƒì´ë‹¤. ì•„ë˜ ì½”ë“œë¥¼ ë³´ì

```swift
class Person {
    let name: String
    init(name: String) { self.name = name }
    var apartment: Apartment? // Person -> Apartment ì°¸ì¡°
    deinit { print("\(name) is being deinitialized") }
}

class Apartment {
    let unit: String
    init(unit: String) { self.unit = unit }
    var tenant: Person? // Apartment -> Person ì°¸ì¡°
    deinit { print("Apartment \(unit) is being deinitialized") }
}

var john: Person?
var unit4A: Apartment?

// ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ë° ì°¸ì¡°
john = Person(name: "John Appleseed")
unit4A = Apartment(unit: "4A")

// ìƒí˜¸ì°¸ì¡° ë°œìƒ!
john!.apartment = unit4A
unit4A!.tenant = john
```

ì£¼ì„ íë¦„ì„ ë”°ë¼ê°€ë‹¤ ë³´ë©´ ìì—°ìŠ¤ë ˆ Personâ†”Apartment ê°„ì— ìƒí˜¸ì°¸ì¡°ê°€ ë°œìƒí•œë‹¤ëŠ” ê²ƒì„ ì´í•´í•  ìˆ˜ ìˆë‹¤. í˜„ì¬ ì°¸ì¡°ìƒí™©ì„ ê·¸ë¦¼ìœ¼ë¡œ ë‚˜íƒ€ë‚´ë©´ ì•„ë˜ì™€ ê°™ë‹¤.

![1](https://user-images.githubusercontent.com/35067611/104595939-a0fe7780-56b6-11eb-9cf4-1ebeacd5d044.png)

í˜„ì¬ Person, ApartmentëŠ” ê°ê° 2ì˜ ARC ê°’ì„ ê°–ëŠ”ë‹¤ (ì¸ìŠ¤í„´ìŠ¤ë¡œ í–¥í•˜ëŠ” ì°¸ì¡°ê°€ 2ê°œ). ì´ ìƒíƒœì—ì„œ ê° í´ë˜ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì°¸ì¡°í•˜ëŠ” ë³€ìˆ˜ì˜ ê°’ì„ nilë¡œ ë°”ê¾¸ì–´ë³´ì.

```swift
john = nil
unit4A = nil
// deinit messageê°€ ì¶œë ¥ë˜ì§€ ì•ŠëŠ”ë‹¤, ì¦‰ ë©”ëª¨ë¦¬ í•´ì œê°€ ì •ìƒì ìœ¼ë¡œ ì¼ì–´ë‚˜ì§€ ì•Šì•˜ë‹¤!!
```

ì™œ ì™€ì´!? ë¶„ëª… nil ì²˜ë¦¬ë¥¼ í•´ì£¼ì—ˆëŠ”ë° ARCê°€ ì¤„ì–´ë“¤ì§€ ì•Šì•˜ë‹¤ê³ ?

![2](https://user-images.githubusercontent.com/35067611/104595943-a2c83b00-56b6-11eb-8245-4c965bd1755b.png)

ê° ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì°¸ì¡°í•˜ëŠ” `john`, `unit4A` ë³€ìˆ˜ë¡œë¶€í„° ë‚˜ì˜¤ëŠ” ì°¸ì¡°ëŠ” ëŠì—ˆìœ¼ë‚˜ í´ë˜ìŠ¤ ë‚´ë¶€ì˜ ë³€ìˆ˜ë¼ë¦¬ ìƒí˜¸ì°¸ì¡°ëŠ” ì—¬ì „íˆ ì‚´ì•„ìˆì–´ì„œ ARC ì…ì¥ì—ì„œëŠ” ë‘ ì¸ìŠ¤í„´ìŠ¤ ëª¨ë‘ ë©”ëª¨ë¦¬ì—ì„œ í•´ì œí•  ìˆ˜ ì—†ëŠ” ê²ƒì´ë‹¤.

ê·¸ë ‡ë‹¤ë©´ ì´ëŸ° ë¬¸ì œë¥¼ ì–´ë–»ê²Œ í•´ê²°í•  ìˆ˜ ìˆì„ê¹Œ?

### 1. `Weak` References

A weak reference is a reference that does not keep a strong hold on the instance it refers to, and so does not stop ARC from disposing of the referenced instance.

ARCëŠ” ê°•í•œì°¸ì¡°ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì°¸ì¡°ì˜ ê°œìˆ˜ë¥¼ ì„¸ëŠ”ë° weak í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ë©´ ê°•í•œì°¸ì¡°ë¥¼ holdí•˜ì§€ ì•Šìœ¼ë‹ˆê¹Œ ì´ëŸ° ìˆœí™˜ì°¸ì¡° ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆë‹¤!

```swift
class Apartment {
    let unit: String
    init(unit: String) { self.unit = unit }
    // Apartment í´ë˜ìŠ¤ë¥¼ ì´ë ‡ê²Œ ë°”ê¿”ë³´ì
    weak var tenant: Person?
    deinit { print("Apartment \(unit) is being deinitialized") }
}
```

ì´ë ‡ê²Œ weak í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ë©´ ì°¸ì¡°ì˜ ì–‘ìƒì´ ì•„ë˜ ì‚¬ì§„ê³¼ ê°™ì•„ì§„ë‹¤.

![3](https://user-images.githubusercontent.com/35067611/104595944-a2c83b00-56b6-11eb-9236-6f8a55e8c055.png)

í˜„ì¬ ìƒíƒœë¥¼ ìì„¸íˆ ë³´ì. Person ì¸ìŠ¤í„´ìŠ¤ì˜ ARCëŠ” 1, ApartmentëŠ” 2ë‹¤. ê·¸ëŸ¬ë¯€ë¡œ john ë³€ìˆ˜ë¥¼ nil ì²˜ë¦¬í•´ì£¼ë©´ Person ì¸ìŠ¤í„´ìŠ¤ëŠ” ë©”ëª¨ë¦¬ì—ì„œ í•´ì œë  ê²ƒì´ê³  ë‹¹ì—°íˆ Person ê°ì²´ ë‚´ì˜ apartment ë³€ìˆ˜ë„ ë©”ëª¨ë¦¬ì—ì„œ ì‚¬ë¼ì§„ë‹¤. ê²°ê³¼ì ìœ¼ë¡œ Apartment ì¸ìŠ¤í„´ìŠ¤ë„ ARCê°€ 1(unit4A ë³€ìˆ˜)ë¡œ ì¤„ì–´ë“¤ê²Œ ëœë‹¤.

```swift
john = nil // "John Appleseed is being deinitialized"
```

![4](https://user-images.githubusercontent.com/35067611/104595949-a360d180-56b6-11eb-906d-e26563c0188f.png)

Apartment í´ë˜ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ë„ ARCê°€ 1ì´ë¯€ë¡œ unit4Aê°€ ê°€ë¦¬í‚¤ëŠ” ê°•í•œì°¸ì¡°ë§Œ ëŠì–´ì£¼ë©´ ì •ìƒì ìœ¼ë¡œ deinit ì‹œí‚¬ ìˆ˜ ìˆë‹¤.

```swift
unit4A = nil // "Apartment 4A is being deinitialized"
```

![5](https://user-images.githubusercontent.com/35067611/104595951-a3f96800-56b6-11eb-934b-30a776ea488c.png)

### 2. `Unowned` References

weakê³¼ ë§ˆì°¬ê°€ì§€ë¡œ ê°•í•œì°¸ì¡°ë¥¼ ë§Œë“¤ì§€ ì•ŠëŠ” unowned í‚¤ì›Œë“œê°€ ìˆë‹¤. ì°¨ì´ì ì´ë¼ë©´ ë‹¤ë¥¸ ì¸ìŠ¤í„´ìŠ¤ê°€ ê°™ê±°ë‚˜ ë” ê¸´ lifetimeì„ ê°€ì§ˆ ë•Œë§Œ ì‚¬ìš©í•œë‹¤ëŠ” ì ì´ë‹¤.

unowned reference is used when the other instance has the same lifetime or a longer lifetime

ê°€ë¦¬í‚¤ëŠ” ì¸ìŠ¤í„´ìŠ¤ì˜ lifetimeì´ ì–´ë–¤ ì˜ë¯¸ë¥¼ ê°–ê¸¸ë˜ ê°™ê±°ë‚˜ ë” ê¸¸ì–´ì•¼í• ê¹Œ? ê·¸ ì´ìœ ëŠ” weak í‚¤ì›Œë“œëŠ” ê°€ë¦¬í‚¤ê³  ìˆëŠ” ë©”ëª¨ë¦¬ ê³µê°„ì´ í•´ì œë˜ì—ˆë‹¤ë©´ í•´ë‹¹ ì°¸ì¡°ë¥¼ nilë¡œ ë°”ê¿”ì£¼ì§€ë§Œ unownedëŠ” ê·¸ë ‡ì§€ ì•Šê¸° ë•Œë¬¸ì´ë‹¤. ì¦‰ unownedëŠ” ì°¸ì¡°ë˜ëŠ” ì¸ìŠ¤í„´ìŠ¤ê°€ ë©”ëª¨ë¦¬ì— í•­ìƒ ê°’ì´ ìˆê¸°ë¥¼ ê¸°ëŒ€í•˜ê³  ê·¸ë ‡ì§€ ì•Šì„ ê²½ìš° ëŸ°íƒ€ì„ ì—ëŸ¬ë¥¼ ë±‰ëŠ”ë‹¤.

Use an unowned reference only when you are sure that the reference always refers to an instance that has not been deallocated.

If you try to access the value of an unowned reference after that instance has been deallocated, youâ€™ll get a runtime error.

ì´ ì°¨ì´ì ì— ëŒ€í•´ ì œëŒ€ë¡œ ì¸ì§€í•˜ê³  weakê³¼ unownedë¥¼ ì ì ˆíˆ ì‚¬ìš©í•˜ë©´ ë˜ê² ë‹¤.

## ì„¸ ì¤„ ìš”ì•½

- ARCëŠ” ë§ŒëŠ¥ì´ ì•„ë‹ˆë‹¤! ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ê°€ ë°œìƒí•˜ëŠ”ì§€ í•­ìƒ ì²´í¬í•˜ì.
- strong reference ê°„ ìˆœí™˜ì°¸ì¡°ê°€ ì¼ì–´ë‚˜ì§€ ì•Šë„ë¡ weak, unownedë¥¼ ì´í•´í•˜ê³  ì‚¬ìš©í•´ì•¼í•œë‹¤.
- weakê³¼ unownedì˜ ì°¨ì´ì ì€ ì°¸ì¡°í•˜ëŠ” ì¸ìŠ¤í„´ìŠ¤ê°€ nilì´ ë  ìˆ˜ ìˆëŠ”ê°€/ì—†ëŠ”ê°€ì´ë‹¤.

## References

[Automatic Reference Counting - The Swift Programming Language (Swift 5.3)](https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html)
