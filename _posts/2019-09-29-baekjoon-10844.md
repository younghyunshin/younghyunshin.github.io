---
layout: post
title: "백준 10844번 : 쉬운 계단 수"
tags: [알고리즘, 백준, DP]
comments: true
---

> BOJ  

### 문제설명  
45656이란 수를 보자. 이 수는 인접한 모든 자리수의 차이가 1이 난다. 이런 수를 계단 수라고 한다. 세준이는 수의 길이가 N인 계단 수가 몇 개 있는지 궁금해졌다.  
N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구하는 프로그램을 작성하시오. (0으로 시작하는 수는 없다.)  

입력  
첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.  

출력  
첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.  

### 접근  
처음에는 점화식을 세울 때 길이 N과 N+1 사이의 관계를 생각했다.  
길이가 N일 때 0과 9가 있다면 자릿수가 하나 늘어났을 때 뒤에 올 수 있는 숫자는 0 -> 9, 1 중 1만 올 수 있고 9 -> 8, 0 중 8만 올 수 있다. 자릿수가 바뀌기 때문이다. 나머지 2~8의 경우의 수에는 다음 자리에 1,3 2,4 3,5 등등 두 가짓수로 갈리므로 x2를 해주면 된다. 즉 N자릿수에서 0과 9의 갯수에 따라 N+1 단계의 가짓수가 달라진다고 생각했다. 점화식을 세우려 경우의 수를 따져보니  
~~~
t를 N-1의 0과 9의 갯수라고 할 때,
dp[n] = (dp[n-1] - t) * 2 + t
~~~

하지만 각 N에서 t의 갯수가 규칙을 가지고 증가하는 것이 아니었다. 여기서 멘붕.. 그러다 옆에 있던 예준이가 도움을 줘서 "DP답게" 풀었다.  

배열 index 0~9를 길이 N일 때 가능한 끝나는 자릿수라고 하자. 그리고 N이 하나씩 증가하면 dp[n][j] = dp[n-1][j-1] + dp[n-1][j+1]로 기록할 수 있다.
~~~
idx   0 1 2 3 4 5 6 7 8 9
dp[0] 0 1 1 1 1 1 1 1 1 1
dp[1] 1 1 2 2 2 2 2 2 2 1
dp[2] 1 3 3 4 4 4 4 4 3 2
...
~~~

그렇게 코드를 짰는데 여기서 한 단계 더 나아가 공간복잡도를 줄일 수 있다. 배열을 N개 만큼 선언하는 것이아니라 2개만 공간을 잡아두고 값을 더해서 다음 행에 숫자를 기록할 때 윗배열, 아랫배열로 값을 계속 옮겨다니는 것이다. 이것을 슬라이딩 윈도 기법이라도 한다.  

갓예준.. 오늘도 한 수 배웠다!!  

### 코드  
~~~c++
#include <cstdio>
using namespace std;

#define MOD 1000000000

int main() {

    int n, i, j;
    int dp[101][11] = { 0, };
    int sum = 0;

    scanf("%d", &n);

    for (i = 0; i <= 9; i++) dp[1][i] = 1;

    for (i = 2; i <= n; i++) {
        dp[i][0] = dp[i-1][1];
        dp[i][10] = 0;
        for (j = 0; j <= 9; j++) {
            dp[i][j] = (dp[i-1][j-1] + dp[i-1][j+1]) % MOD;
        }
    }

    for (i = 1; i <= 9; i++) sum = (sum + dp[n][i]) % MOD;
    printf("%d\n", sum);

    return 0;
}
~~~

슬라이딩 윈도우 기법 (예준이 코드 지렸다리..)
~~~c++
#include <bits/stdc++.h>
#define MOD 1000000000

using namespace std;

int a[2][12];

int main() {
    int n, ans = 9;

    scanf("%d", &n);

    for(int i = 2; i < 11; i++)
        a[1][i] = 1;

    for(int i = 2; i <= n; i++) {
        ans = 0;
        for(int j = 1; j < 11; j++) {
            a[i%2][j] = (a[(i-1)%2][j-1] + a[(i-1)%2][j+1]) % MOD;
            ans = (ans + a[i%2][j]) % MOD;
        }
    }

    printf("%d", ans);

    return 0;
}
~~~
