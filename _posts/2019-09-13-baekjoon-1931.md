---
layout: post
title: "백준 1931번 : 회의실 배정"
tags: [알고리즘, 백준, Greedy]
comments: true
---

> BOJ  

### 문제설명  
한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의들에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 최대수의 회의를 찾아라. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.  

입력  
첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 231-1보다 작거나 같은 자연수 또는 0이다.  

출력  
첫째 줄에 최대 사용할 수 있는 회의 수를 출력하여라.  

### 접근  
그리디 알고리즘 측면에서는 크게 어렵지 않은 문제이다. 회의가 끝나는 시간을 기준으로 정렬 한 후, 배열(혹은 벡터)의 남은 회의들의 시작시간이 진행 중인 회의의 끝나는 시간보다 크거나 같다면 선택하고 작으면 선택하지 않으면 된다. 다만, 트릭이 숨어있는데 회의가 끝나는 시간을 기준으로 정렬했을 때 그 시간이 같다면 회의 시작 시간을 기준으로 정렬해야 한다는 것이다.  

그 이유는 회의종료시간은 같을 경우 시작 시간이 더 앞서는 회의가 높은 우선순위여야 하는데 그런 회의가 입력 순서 상으로 뒤에 온다면 한 번의 정렬로는 greedy한 선택이 되지 않기 때문이다. 예를 들어 입력이 다음과 같다고 하자.  
(2, 3)  
(1, 3)  
(5, 3)  
입력 순서가 위와 같다면 회의 종료시간을 기준으로 정렬할 경우 위 리스트는 그대로일 것이다. 하지만 이 문제가 원하는 순서는 다음과 같다.  
(1, 3)  
(2, 3)  
(5, 3)  

그러므로 회의종료시간을 기준으로 정렬하되, 같을 경우엔 시작시간을 기준으로 정렬하는 것 까지 고려해주어야 한다.  

### 코드  
~~~c++
#include <cstdio>
#include <vector>
#include <utility>
#include <algorithm>

using namespace std;
bool sortbysec(const pair<int,int> &a, const pair<int,int> &b) {
    return (a.second < b.second);
}
int main() {

    int N, i, n1, n2, min, cnt = 0;

    scanf("%d", &N);
    vector <pair <int, int> > v;

    for (i = 0; i < N; i++) {
        scanf("%d %d", &n1, &n2);
        v.push_back(make_pair(n1, n2));
    }
    sort(v.begin(), v.end());
    sort(v.begin(), v.end(), sortbysec);

    min = v[0].second;
    cnt++;

    for (i = 1; i < N; i++) {
        if (v[i].first >= min) {
            min = v[i].second;
            cnt++;
        }
    }

    printf("%d\n", cnt);
    return 0;
}
~~~
