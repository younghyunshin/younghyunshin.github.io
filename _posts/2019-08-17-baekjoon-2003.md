---
layout: post
title: "백준 2003번 : 수들의 합 2"
tags: [알고리즘, 백준, 투포인터]
comments: true
---

> BOJ  

### 문제설명  
N개의 수로 된 수열 A[1], A[2], …, A[N] 이 있다. 이 수열의 i번째 수부터 j번째 수까지의 합 A[i]+A[i+1]+…+A[j-1]+A[j]가 M이 되는 경우의 수를 구하는 프로그램을 작성하시오.  

입력  
첫째 줄에 N(1≤N≤10,000), M(1≤M≤300,000,000)이 주어진다. 다음 줄에는 A[1], A[2], …, A[N]이 공백으로 분리되어 주어진다. 각각의 A[x]는 30,000을 넘지 않는 자연수이다.  

출력  
첫째 줄에 경우의 수를 출력한다.  

### 접근  
투 포인터라는 알고리즘을 새로 배운 문제다. 모든 경우의 수를 따지는 방법은 시간초과로 실패다. 투 포인터는 실제 포인터를 이용하는 것이 아니라 주어진 배열에서 두 곳을 가리키도록 해서 문제를 해결하는 방법이다. 가리킨다는 것은 배열의 인덱스를 의미한다. 이 문제와 같이 특정 구간의 수들의 합이 M이 되는지 묻는 문제에 적합하다. 알고리즘은 다음과 같다.  

먼저 low, high 포인터를 0으로 두고 조건에 따라 구간을 늘리거나 줄여가며 그 구간의 합과 문제의 M을 비교한다.  
구간의 합(sum)이 M보다 크거나 같을 경우, low 포인터가 가리키는 곳의 수를 sum에서 빼고 low를 한칸 움직인다.  
high 포인터가 N까지 닿을 경우 반복문을 탈출한다.  
sum이 M보다 작을 경우에는 구간을 늘린다. (high 포인터를 한 칸 옮긴다)  
위 과정을 반복하는 중에서 sum과 M이 같을 때마다 cnt 변수를 하나씩 올려서 경우의 수를 체크한다.  

### 코드  
~~~c++
#include <cstdio>
using namespace std;

int main() {
    int N, M, i;
    int l = 0, h = 0, cnt = 0, sum = 0;
    int arr[10000];

    scanf("%d %d", &N, &M);
    for (i = 0; i < N; i++) {
        scanf(" %d", &arr[i]);
    }

    while(1) {
        if (sum >= M) sum -= arr[l++];
        else if (h == N) break;
        else sum += arr[h++];

        if (sum == M) cnt++;
    }

    printf("%d\n", cnt);
    return 0;
}
~~~
