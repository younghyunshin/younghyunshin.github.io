---
layout: post
title: "백준 11054번 : 가장 긴 바이토닉 부분 수열"
tags: [알고리즘, 백준, DP, LIS]
comments: true
---

> BOJ  

### 문제설명  
수열 S가 어떤 수 Sk를 기준으로 S1 < S2 < ... Sk-1 < Sk > Sk+1 > ... SN-1 > SN을 만족한다면, 그 수열을 바이토닉 수열이라고 한다.  

예를 들어, {10, 20, 30, 25, 20}과 {10, 20, 30, 40}, {50, 40, 25, 10} 은 바이토닉 수열이지만,  {1, 2, 3, 2, 1, 2, 3, 2, 1}과 {10, 20, 30, 40, 20, 30} 은 바이토닉 수열이 아니다.  

수열 A가 주어졌을 때, 그 수열의 부분 수열 중 바이토닉 수열이면서 가장 긴 수열의 길이를 구하는 프로그램을 작성하시오.  

입력  
첫째 줄에 수열 A의 크기 N이 주어지고, 둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ N ≤ 1,000, 1 ≤ Ai ≤ 1,000)  

출력  
첫째 줄에 수열 A의 부분 수열 중에서 가장 긴 바이토닉 수열의 길이를 출력한다.  

### 접근  
가장 긴 부분 수열을 구하는 문제에서 조금만 생각을 창의적으로 하면 풀리는 문제다. 바이토닉 수열의 특징은 특정 수 까지 증가하고 그 이후부터는 감소한다는 것이다.  

가장 긴 부분 수열을 왼쪽에서 오른쪽으로 한번, 오른쪽에서 왼쪽으로 한번 적용하여 두 배열의 값을 기록해 놓는다면 각 위치까지 가장 긴 증가하는 길이와 감소하는 길이 정보 모두를 얻을 수 있다. 그리고 두 배열을 합치고 그 중 가장 큰 값을 가져오면 된다. 단, 자기자신의 길이를 포함하고 있기 때문에 1을 빼준다.  

### 코드  
~~~c++
#include <cstdio>
using namespace std;

int get_max (int a, int b) { return a > b ? a : b; }
int main() {

    int N, i, j, max = 0;
    
    scanf("%d", &N);
    int arr[N+1];
    int dpi[N+1]; dpi[0] = 0;
    int dpd[N+2]; dpd[N+1] = 0;
    int dp[N+1];
    
    for (i = 1; i <= N; i++) scanf("%d", &arr[i]);

    for (i = 1; i <= N; i++) {
        dpi[i] = 1;
        dpd[N-i+1] = 1;
        for (j = 1; j < i; j++) {
            if ( arr[i] > arr[j] && dpi[j] + 1 > dpi[i]) dpi[i] = dpi[j] + 1;
            if ( arr[N-i+1] > arr[N-j+1] && dpd[N-j+1] + 1 > dpd[N-i+1]) dpd[N-i+1] = dpd[N-j+1] + 1;
        }
    }

    for (i = 1; i <= N; i++) {
        dp[i] = dpi[i] + dpd[i];
        max = get_max(max, dp[i]);
        
    }
    printf("%d\n", max-1);

    return 0;
}
~~~